`timescale	1ps / 1ps
////////////////////////////////////////////////////////////////////////////////
//
// Filename:	./main.v
//
// Project:	VideoZip, a ZipCPU SoC supporting video functionality
//
// DO NOT EDIT THIS FILE!
// Computer Generated: This file is computer generated by AUTOFPGA. DO NOT EDIT.
// DO NOT EDIT THIS FILE!
//
// CmdLine:	autofpga autofpga -d -o . genclk.txt netclockctr.txt global.txt dlyarbiter.txt icape.txt version.txt buserr.txt pic.txt pwrcount.txt xpander.txt vidarbiter.txt spio.txt gpio.txt rtcgps.txt rtcdate.txt wbuconsole.txt bkram.txt flash.txt sdvidram.txt zipmaster.txt mdio.txt enet.txt gps.txt sdspi.txt hdmi.txt cpuscope.txt enetscope.txt mem_bkram_only.txt mem_flash_bkram.txt clkcounter.txt wbmouse.txt wbpmic.txt xdc.txt
//
// Creator:	Dan Gisselquist, Ph.D.
//		Gisselquist Technology, LLC
//
////////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 2017-2019, Gisselquist Technology, LLC
//
// This program is free software (firmware): you can redistribute it and/or
// modify it under the terms of  the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License, or (at
// your option) any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// You should have received a copy of the GNU General Public License along
// with this program.  (It's in the $(ROOT)/doc directory.  Run make with no
// target there if the PDF file isn't present.)  If not, see
// <http://www.gnu.org/licenses/> for a copy.
//
// License:	GPL, v3, as defined and found on www.gnu.org,
//		http://www.gnu.org/licenses/gpl.html
//
//
////////////////////////////////////////////////////////////////////////////////
//
//
`default_nettype	none
//
//
// Here is a list of defines which may be used, post auto-design
// (not post-build), to turn particular peripherals (and bus masters)
// on and off.  In particular, to turn off support for a particular
// design component, just comment out its respective `define below.
//
// These lines are taken from the respective @ACCESS tags for each of our
// components.  If a component doesn't have an @ACCESS tag, it will not
// be listed here.
//
// First, the independent access fields for any bus masters
`define	INCLUDE_ZIPCPU
`define	WBUBUS_MASTER
// And then for the independent peripherals
`define	HDMI_OUT_EDID_ACCESS
`define	GPSTRK_ACCESS
`define	ETHERNET_ACCESS
`define	FLASH_ACCESS
`define	HDMIIN_ACCESS
`define	ARBITRARY_CLOCK_GENERATOR_ACCESS
`define	MOUSE_ACCESS
`define	HDMI_IN_EDID_ACCESS
`define	MICROPHONE_ACCESS
`define	GPIO_ACCESS
`define	SDRAM_ACCESS
`define	GPSUART_ACCESS
`define	BUSPIC_ACCESS
`define	CFG_ACCESS
`define	SDSPI_ACCESS
`define	SPIO_ACCESS
`define	RTC_ACCESS
`define	BKRAM_ACCESS
`define	PWRCOUNT_ACCESS
`define	BUSCONSOLE_ACCESS
`define	NETCTRL_ACCESS
//
//
// The list of those things that have @DEPENDS tags
//
//
// Dependencies are listed within the @DEPENDS tag
// Values prefixed by a !, yet with no spaces between the ! and the
// dependency, are ifndef dependencies.  As an example, an
// an access and depends tag such as:
//
// @ACCESS=  THIS_COMPONENT
// @DEPENDS= MUST_HAVE_A !MUST_NOT_HAVE_B
//
// will turn into:
//
// `ifdef MUST_HAVE_A
// `ifndef MUST_NOT_HAVE_B
// `define THIS_COMPONENT
// `endif // MUST_NOT_HAVE_B
// `endif // MUST_HAVE_A
//
`ifdef	RTC_ACCESS
`define	RTCDATE_ACCESS
`endif
`ifdef	SDSPI_ACCESS
`define	SDSPI_SCOPE
`endif
`ifdef	FLASH_ACCESS
`define	FLASHCTL_ACCESS
`endif
`ifdef	ETHERNET_ACCESS
`ifdef	GPSTRK_ACCESS
`define	NETCLOCKCTR_ACCESS
`endif
`endif
`ifdef	ETHERNET_ACCESS
`define	NETSCOPE_SCOPE
`endif
//
// End of dependency list
//
//
//
//
// Finally, we define our main module itself.  We start with the list of
// I/O ports, or wires, passed into (or out of) the main function.
//
// These fields are copied verbatim from the respective I/O port lists,
// from the fields given by @MAIN.PORTLIST
//
module	main(i_clk, i_reset,
		// HDMI out (source) EDID I2C ports
		i_hdmi_out_scl, i_hdmi_out_sda, o_hdmi_out_scl, o_hdmi_out_sda,
		// The GPS 1PPS signal port
		i_gps_pps,
		// Ethernet control (packets) lines
		o_net_reset_n,
		// eth_int_b	// Interrupt, leave floating
		// eth_pme_b	// Power management event, leave floating
		i_net_rx_clk, i_net_rx_ctl, i_net_rxd,
		o_net_tx_clk, o_net_tx_ctl, o_net_txd,
		// HDMI output ports
		i_hdmi_out_clk,
		// HDMI output pixels
		o_hdmi_out_r, o_hdmi_out_g, o_hdmi_out_b,
		i_cpu_reset,
		// The QSPI Flash
		o_qspi_cs_n, o_qspi_sck, o_qspi_dat, i_qspi_dat, o_qspi_mod,
		// HDMI input ports
		i_hdmi_in_clk,
		i_hdmi_in_r, i_hdmi_in_g, i_hdmi_in_b,
		i_hdmi_in_hsclk, i_clk_200mhz,
		// HDMI input delay control
		i_hdmi_in_actual_delay_r, i_hdmi_in_actual_delay_g,
		i_hdmi_in_actual_delay_b, o_hdmi_in_delay,
		// Clock generator ports
		i_genclk_clk,
		i_genclk_pll_locked,
		o_genclk_word,
		o_genclk_ce,
		// The PS/2 Mouse
		i_ps2, o_ps2,
		// HDMI input EDID I2C ports
		i_hdmi_in_scl, i_hdmi_in_sda, o_hdmi_in_scl, o_hdmi_in_sda,
		// UART/host to wishbone interface
		i_wbu_uart_rx, o_wbu_uart_tx,
		// The PMic3 microphone wires
		o_mic_csn, o_mic_sck, i_mic_din,
		// GPIO ports
		i_gpio, o_gpio,
		o_sdram_cyc, o_sdram_stb, o_sdram_we,
				o_sdram_addr, o_sdram_data, o_sdram_sel,
			i_sdram_ack, i_sdram_stall, i_sdram_data,
		// The GPS-UART
		i_gpsu_rx, o_gpsu_tx,
		// The SD-Card wires
		o_sd_sck, o_sd_cmd, o_sd_data, i_sd_cmd, i_sd_data, i_sd_detect,
		// SPIO interface
		i_sw, i_btnc, i_btnd, i_btnl, i_btnr, i_btnu, o_led,
		// The ethernet MDIO wires
		o_mdclk, o_mdio, o_mdwe, i_mdio);
//
// Any parameter definitions
//
// These are drawn from anything with a MAIN.PARAM definition.
// As they aren't connected to the toplevel at all, it would
// be best to use localparam over parameter, but here we don't
// check
	localparam [31:0] GPSCLOCK_DEFAULT_STEP = 32'haabcc771;
`define	ENETRX_SCOPE
	//
	//
	// Variables/definitions needed by the ZipCPU BUS master
	//
	//
	// A 32-bit address indicating where the ZipCPU should start running
	// from
	localparam	RESET_ADDRESS = 306184192;
	//
	// The number of valid bits on the bus
	localparam	ZIP_ADDRESS_WIDTH = 28; // Zip-CPU address width
	//
	// Number of ZipCPU interrupts
	localparam	ZIP_INTS = 16;
	//
	// ZIP_START_HALTED
	//
	// A boolean, indicating whether or not the ZipCPU be halted on startup?
	localparam	ZIP_START_HALTED=1'b1;
	localparam	ICAPE_LGDIV=3;
//
// The next step is to declare all of the various ports that were just
// listed above.  
//
// The following declarations are taken from the values of the various
// @MAIN.IODECL keys.
//
	input	wire		i_clk;
// verilator lint_off UNUSED
	input	wire		i_reset;
	// verilator lint_on UNUSED
	// HDMI input EDID I2C ports
	input	wire		i_hdmi_out_scl, i_hdmi_out_sda;
	output	wire		o_hdmi_out_scl, o_hdmi_out_sda;
	//The GPS Clock
	input	wire		i_gps_pps;
	// Ethernet control
	output	wire		o_net_reset_n;
	input	wire		i_net_rx_clk, i_net_rx_ctl;
	input	wire	[7:0]	i_net_rxd;
	output	wire		o_net_tx_clk;
	output	wire		o_net_tx_ctl;
	output	wire	[7:0]	o_net_txd;
	// Verilator lint_off UNUSED
	// HDMI output clock
	input	wire	i_hdmi_out_clk;
	// Verilator lint_on  UNUSED
	// HDMI output pixels
	output	wire	[9:0]	o_hdmi_out_r, o_hdmi_out_g, o_hdmi_out_b;
	input	wire		i_cpu_reset;
	// The QSPI flash
	output	wire		o_qspi_cs_n, o_qspi_sck;
	output	wire	[3:0]	o_qspi_dat;
	input	wire	[3:0]	i_qspi_dat;
	output	wire	[1:0]	o_qspi_mod;
	// HDMI input ports
	input	wire		i_hdmi_in_clk;
	input	wire	[9:0]	i_hdmi_in_r, i_hdmi_in_g, i_hdmi_in_b;
	// verilator lint_off UNUSED
	input	wire		i_hdmi_in_hsclk;
	// verilator lint_on  UNUSED
	input	wire		i_clk_200mhz;
	// Sub-pixel delay control
	input	wire	[4:0]	i_hdmi_in_actual_delay_r;
	input	wire	[4:0]	i_hdmi_in_actual_delay_g;
	input	wire	[4:0]	i_hdmi_in_actual_delay_b;
	output	wire	[4:0]	o_hdmi_in_delay;
	input	wire		i_genclk_clk;
	input	wire		i_genclk_pll_locked;
	output	wire	[7:0]	o_genclk_word;
	output	wire		o_genclk_ce;
	// The PS/2 Mouse
	input		[1:0]	i_ps2;
	output	wire	[1:0]	o_ps2;
	// HDMI input EDID I2C ports
	input	wire		i_hdmi_in_scl, i_hdmi_in_sda;
	output	wire		o_hdmi_in_scl, o_hdmi_in_sda;
	input	wire		i_wbu_uart_rx;
	output	wire		o_wbu_uart_tx;
	output	wire		o_mic_csn, o_mic_sck;
	input	wire		i_mic_din;
	localparam	NGPI = 16, NGPO=16;
	// GPIO ports
	input		[(NGPI-1):0]	i_gpio;
	output	wire	[(NGPO-1):0]	o_gpio;
	output	wire	o_sdram_cyc, o_sdram_stb, o_sdram_we;
	output	wire	[(25-1):0]	o_sdram_addr;
	output	wire	[(128-1):0]	o_sdram_data;
	output	wire	[(128/8)-1:0]	o_sdram_sel;
	//
	input	wire	i_sdram_ack;
	input	wire	i_sdram_stall;
	input	wire	[(128-1):0]	i_sdram_data;
	input	wire		i_gpsu_rx;
	output	wire		o_gpsu_tx;
	// SD-Card declarations
	output	wire		o_sd_sck, o_sd_cmd;
	output	wire	[3:0]	o_sd_data;
	// verilator lint_off UNUSED
	input	wire		i_sd_cmd;
	input	wire	[3:0]	i_sd_data;
	input	wire		i_sd_detect;
	// verilator lint_on  UNUSED
	// SPIO interface
	input	wire	[8-1:0]	i_sw;
	input	wire		i_btnc, i_btnd, i_btnl, i_btnr, i_btnu;
	output	wire	[8-1:0]	o_led;
	// Ethernet control (MDIO)
	output	wire		o_mdclk, o_mdio, o_mdwe;
	input	wire		i_mdio;
	// Make Verilator happy ... defining bus wires for lots of components
	// often ends up with unused wires lying around.  We'll turn off
	// Verilator's lint warning here that checks for unused wires.
	// verilator lint_off UNUSED



	//
	// Declaring interrupt lines
	//
	// These declarations come from the various components values
	// given under the @INT.<interrupt name>.WIRE key.
	//
	wire	edid_out_int;	// edout.INT.EDID.WIRE
	wire	scop_edid_int;	// scop_edid.INT.SCOPE.WIRE
	wire	ck_pps;	// gck.INT.PPS.WIRE
	wire	enetscope_int;	// enetscope.INT.ENETSCOPE.WIRE
	wire	nettx_int;	// netp.INT.NETTX.WIRE
	wire	netrx_int;	// netp.INT.NETRX.WIRE
	wire	zip_cpu_int;	// zip.INT.ZIP.WIRE
	wire	flash_interrupt;	// flash.INT.FLASH.WIRE
	wire	hdmiin_int;	// hdmiin.INT.VSYNC.WIRE
	wire	mous_interrupt;	// mous.INT.MOUSE.WIRE
	wire	zipscope_int;	// zipscope.INT.ZIPSCOPE.WIRE
	wire	scope_sdcard_int;	// scope_sdcard.INT.SDSCOPE.WIRE
	wire	scop_hdmiin_int;	// scope_hdmiin.INT.HINSCOPE.WIRE
	wire	pmic_int;	// pmic.INT.MIC.WIRE
	wire	gpio_int;	// gpio.INT.GPIO.WIRE
	wire	gpsutx_int;	// gpsu.INT.GPSTX.WIRE
	wire	gpsutxf_int;	// gpsu.INT.GPSTXF.WIRE
	wire	gpsurx_int;	// gpsu.INT.GPSRX.WIRE
	wire	gpsurxf_int;	// gpsu.INT.GPSRXF.WIRE
	wire	w_bus_int;	// buspic.INT.BUS.WIRE
	wire	sdcard_int;	// sdcard.INT.SDCARD.WIRE
	wire	spio_int;	// spio.INT.SPIO.WIRE
	wire	rtc_int;	// rtc.INT.RTC.WIRE
	wire	uarttxf_int;	// uart.INT.UARTTXF.WIRE
	wire	uartrxf_int;	// uart.INT.UARTRXF.WIRE
	wire	uarttx_int;	// uart.INT.UARTTX.WIRE
	wire	uartrx_int;	// uart.INT.UARTRX.WIRE


	//
	// Component declarations
	//
	// These declarations come from the @MAIN.DEFNS keys found in the
	// various components comprising the design.
	//
// Looking for string: MAIN.DEFNS
	reg	r_sysclk_ack;
	wire	[31:0]	edido_dbg;
	wire		edid_scope_trigger;
	wire	[30:0]	edid_scope_data;
	reg	r_clkhdmiin_ack;
	reg	r_clkhdmiout_ack;
	wire	gps_pps, gps_led, gps_locked, gps_tracking;
	wire	[63:0]	gps_now, gps_err, gps_step;
	wire	[1:0]	gps_dbg_tick;
	wire	tb_pps;
	wire	netp_dbg_trigger;
	//
	wire	[31:0]	netp_debug;
	// ZipSystem/ZipCPU connection definitions
	// All we define here is a set of scope wires
	wire	[31:0]	zip_debug;
	wire		zip_trigger;
	wire	[ZIP_INTS-1:0] zip_int_vector;
`include "builddate.v"
	reg [31:0]	r_hdmi_scope_frame_offset_data;
	reg	r_hdmi_scope_frame_offset_ack;
	initial	r_hdmi_scope_frame_offset_data=0;
	always @(posedge i_clk)
		if ((wb_stb)&&(hdmi_scope_frame_offset_sel)&&(wb_we))
			r_hdmi_scope_frame_offset_data <= wb_data;

	assign	hdmi_scope_frame_offset_data = r_hdmi_scope_frame_offset_data;
	assign	hdmi_scope_frame_offset_stall= 1'b0;
	always @(posedge i_clk)
		r_hdmi_scope_frame_offset_ack <= (wb_stb)&&(hdmi_scope_frame_offset_sel);
// BUILDTIME doesnt need to include builddate.v a second time
// `include "builddate.v"
	reg	r_genclk_test_ack;
	// Bus arbiter's internal lines
	wire		wbu_dwbi_cyc, wbu_dwbi_stb, wbu_dwbi_we,
			wbu_dwbi_ack, wbu_dwbi_stall, wbu_dwbi_err;
	wire	[(28-1):0]	wbu_dwbi_addr;
	wire	[(32-1):0]	wbu_dwbi_odata, wbu_dwbi_idata;
	wire	[(4-1):0]	wbu_dwbi_sel;
	wire	[31:0]	hin_dbg_scope;
	wire	[29:0]	hin_pixels;
	wire	[9:0]	hdmi_in_r;
	wire	[9:0]	hdmi_in_g;
	wire	[9:0]	hdmi_in_b;
`ifndef	GPSTRK_ACCESS
	reg	[31:0]	r_subseconds_data;
`endif
	reg	[30:0]	r_genclk_data;
	wire		w_genclk_stb;
	reg		r_genclk_ack;
	// scrn_mouse is a 32-bit field containing 16-bits of x-position and
	// 16-bits of y position, limited to the size of the screen.
	wire	[31:0]	scrn_mouse;
	wire	[31:0]	edid_dbg;
	wire	scope_sdcard_trigger,
		scope_sdcard_ce;
	//
	//
	// UART interface
	//
	//
	// Baudrate :   2000000
	// Clock    : 100000000
	localparam [23:0] BUSUART = 24'h32;	// 2000000 baud
	wire	[7:0]	wbu_rx_data, wbu_tx_data;
	wire		wbu_rx_stb;
	wire		wbu_tx_stb, wbu_tx_busy;

	wire	w_ck_uart, w_uart_tx;
	// Definitions for the WB-UART converter.  We really only need one
	// (more) non-bus wire--one to use to select if we are interacting
	// with the ZipCPU or not.
	wire	[0:0]	wbubus_dbg;
`ifndef	INCLUDE_ZIPCPU
	//
	// The bus-console depends upon the zip_dbg wires.  If there is no
	// ZipCPU defining them, we'll need to define them here anyway.
	//
	wire		zip_dbg_ack, zip_dbg_stall;
	wire	[31:0]	zip_dbg_data;
`endif
	wire	[31:0]	hdmi_in_data;
	reg	[28-1:0]	r_buserr_addr;
	wire	w_gpsu_cts_n, w_gpsu_rts_n;
	assign	w_gpsu_cts_n=1'b1;
	// Bus arbiter's internal lines
	wire		sdram_arbiteri_cyc, sdram_arbiteri_stb, sdram_arbiteri_we,
			sdram_arbiteri_ack, sdram_arbiteri_stall, sdram_arbiteri_err;
	wire	[(25-1):0]	sdram_arbiteri_addr;
	wire	[(128-1):0]	sdram_arbiteri_odata, sdram_arbiteri_idata;
	wire	[(16-1):0]	sdram_arbiteri_sel;
	wire[31:0]	sdspi_debug;
	wire	[5-1:0]	w_btn;
	// Definitions in support of the GPS driven RTC
	// This clock step is designed to match 100000000 Hz
	localparam	[31:0]	RTC_CLKSTEP = 32'h002af31d;
	wire	rtc_ppd;
	reg	r_rtc_ack;
`ifdef	GPSTRK_ACCESS
	wire	rtc_pps;
`endif
	reg	r_netclockctr_ack;
	reg	[31:0]	r_pwrcount_data;
	// Console definitions
	wire	w_console_rx_stb, w_console_tx_stb, w_console_busy;
	wire	[6:0]	w_console_rx_data, w_console_tx_data;


	//
	// Declaring interrupt vector wires
	//
	// These declarations come from the various components having
	// PIC and PIC.MAX keys.
	//
	wire	[14:0]	sys_int_vector;
	wire	[14:0]	alt_int_vector;
	wire	[14:0]	bus_int_vector;
	//
	//
	// Define bus wires
	//
	//

	// Bus wb
	// Wishbone master wire definitions for bus: wb
	wire		wb_cyc, wb_stb, wb_we, wb_stall, wb_err,
			wb_none_sel;
	reg		wb_many_ack;
	wire	[27:0]	wb_addr;
	wire	[31:0]	wb_data;
	reg	[31:0]	wb_idata;
	wire	[3:0]	wb_sel;
	reg		wb_ack;

	// Wishbone slave definitions for bus wb(SIO), slave buildtime
	wire		buildtime_sel, buildtime_ack, buildtime_stall;
	wire	[31:0]	buildtime_data;

	// Wishbone slave definitions for bus wb(SIO), slave buserr
	wire		buserr_sel, buserr_ack, buserr_stall;
	wire	[31:0]	buserr_data;

	// Wishbone slave definitions for bus wb(SIO), slave buspic
	wire		buspic_sel, buspic_ack, buspic_stall;
	wire	[31:0]	buspic_data;

	// Wishbone slave definitions for bus wb(SIO), slave clkhdmiin
	wire		clkhdmiin_sel, clkhdmiin_ack, clkhdmiin_stall;
	wire	[31:0]	clkhdmiin_data;

	// Wishbone slave definitions for bus wb(SIO), slave clkhdmiout
	wire		clkhdmiout_sel, clkhdmiout_ack, clkhdmiout_stall;
	wire	[31:0]	clkhdmiout_data;

	// Wishbone slave definitions for bus wb(SIO), slave genclk
	wire		genclk_sel, genclk_ack, genclk_stall;
	wire	[31:0]	genclk_data;

	// Wishbone slave definitions for bus wb(SIO), slave genclk_test
	wire		genclk_test_sel, genclk_test_ack, genclk_test_stall;
	wire	[31:0]	genclk_test_data;

	// Wishbone slave definitions for bus wb(SIO), slave gpio
	wire		gpio_sel, gpio_ack, gpio_stall;
	wire	[31:0]	gpio_data;

	// Wishbone slave definitions for bus wb(SIO), slave hdmi_scope_frame_offset
	wire		hdmi_scope_frame_offset_sel, hdmi_scope_frame_offset_ack, hdmi_scope_frame_offset_stall;
	wire	[31:0]	hdmi_scope_frame_offset_data;

	// Wishbone slave definitions for bus wb(SIO), slave netclockctr
	wire		netclockctr_sel, netclockctr_ack, netclockctr_stall;
	wire	[31:0]	netclockctr_data;

	// Wishbone slave definitions for bus wb(SIO), slave pwrcount
	wire		pwrcount_sel, pwrcount_ack, pwrcount_stall;
	wire	[31:0]	pwrcount_data;

	// Wishbone slave definitions for bus wb(SIO), slave rtcdate
	wire		rtcdate_sel, rtcdate_ack, rtcdate_stall;
	wire	[31:0]	rtcdate_data;

	// Wishbone slave definitions for bus wb(SIO), slave spio
	wire		spio_sel, spio_ack, spio_stall;
	wire	[31:0]	spio_data;

	// Wishbone slave definitions for bus wb(SIO), slave subseconds
	wire		subseconds_sel, subseconds_ack, subseconds_stall;
	wire	[31:0]	subseconds_data;

	// Wishbone slave definitions for bus wb(SIO), slave sysclk
	wire		sysclk_sel, sysclk_ack, sysclk_stall;
	wire	[31:0]	sysclk_data;

	// Wishbone slave definitions for bus wb(SIO), slave version
	wire		version_sel, version_ack, version_stall;
	wire	[31:0]	version_data;

	// Wishbone slave definitions for bus wb(DIO), slave gck
	wire		gck_sel, gck_ack, gck_stall;
	wire	[31:0]	gck_data;

	// Wishbone slave definitions for bus wb(DIO), slave mous
	wire		mous_sel, mous_ack, mous_stall;
	wire	[31:0]	mous_data;

	// Wishbone slave definitions for bus wb(DIO), slave rtc
	wire		rtc_sel, rtc_ack, rtc_stall;
	wire	[31:0]	rtc_data;

	// Wishbone slave definitions for bus wb(DIO), slave gtb
	wire		gtb_sel, gtb_ack, gtb_stall;
	wire	[31:0]	gtb_data;

	// Wishbone slave definitions for bus wb(DIO), slave hdmiin
	wire		hdmiin_sel, hdmiin_ack, hdmiin_stall;
	wire	[31:0]	hdmiin_data;

	// Wishbone slave definitions for bus wb(DIO), slave edin
	wire		edin_sel, edin_ack, edin_stall;
	wire	[31:0]	edin_data;

	// Wishbone slave definitions for bus wb(DIO), slave edout
	wire		edout_sel, edout_ack, edout_stall;
	wire	[31:0]	edout_data;

	// Wishbone slave definitions for bus wb, slave enetscope
	wire		enetscope_sel, enetscope_ack, enetscope_stall;
	wire	[31:0]	enetscope_data;

	// Wishbone slave definitions for bus wb, slave pmic
	wire		pmic_sel, pmic_ack, pmic_stall;
	wire	[31:0]	pmic_data;

	// Wishbone slave definitions for bus wb, slave scop_edid
	wire		scop_edid_sel, scop_edid_ack, scop_edid_stall;
	wire	[31:0]	scop_edid_data;

	// Wishbone slave definitions for bus wb, slave scope_hdmiin
	wire		scope_hdmiin_sel, scope_hdmiin_ack, scope_hdmiin_stall;
	wire	[31:0]	scope_hdmiin_data;

	// Wishbone slave definitions for bus wb, slave scope_sdcard
	wire		scope_sdcard_sel, scope_sdcard_ack, scope_sdcard_stall;
	wire	[31:0]	scope_sdcard_data;

	// Wishbone slave definitions for bus wb, slave zipscope
	wire		zipscope_sel, zipscope_ack, zipscope_stall;
	wire	[31:0]	zipscope_data;

	// Wishbone slave definitions for bus wb, slave flctl
	wire		flctl_sel, flctl_ack, flctl_stall;
	wire	[31:0]	flctl_data;

	// Wishbone slave definitions for bus wb, slave gpsu
	wire		gpsu_sel, gpsu_ack, gpsu_stall;
	wire	[31:0]	gpsu_data;

	// Wishbone slave definitions for bus wb, slave sdcard
	wire		sdcard_sel, sdcard_ack, sdcard_stall;
	wire	[31:0]	sdcard_data;

	// Wishbone slave definitions for bus wb, slave uart
	wire		uart_sel, uart_ack, uart_stall;
	wire	[31:0]	uart_data;

	// Wishbone slave definitions for bus wb, slave netp
	wire		netp_sel, netp_ack, netp_stall;
	wire	[31:0]	netp_data;

	// Wishbone slave definitions for bus wb, slave wb_sio
	wire		wb_sio_sel, wb_sio_ack, wb_sio_stall;
	wire	[31:0]	wb_sio_data;

	// Wishbone slave definitions for bus wb, slave cfg
	wire		cfg_sel, cfg_ack, cfg_stall;
	wire	[31:0]	cfg_data;

	// Wishbone slave definitions for bus wb, slave mdio
	wire		mdio_sel, mdio_ack, mdio_stall;
	wire	[31:0]	mdio_data;

	// Wishbone slave definitions for bus wb, slave wb_dio
	wire		wb_dio_sel, wb_dio_ack, wb_dio_stall;
	wire	[31:0]	wb_dio_data;

	// Wishbone slave definitions for bus wb, slave netb
	wire		netb_sel, netb_ack, netb_stall;
	wire	[31:0]	netb_data;

	// Wishbone slave definitions for bus wb, slave bkram
	wire		bkram_sel, bkram_ack, bkram_stall;
	wire	[31:0]	bkram_data;

	// Wishbone slave definitions for bus wb, slave flash
	wire		flash_sel, flash_ack, flash_stall;
	wire	[31:0]	flash_data;

	// Wishbone slave definitions for bus wb, slave xpand
	wire		xpand_sel, xpand_ack, xpand_stall, xpand_err;
	wire	[31:0]	xpand_data;

	// Bus zip
	// Wishbone master wire definitions for bus: zip
	wire		zip_cyc, zip_stb, zip_we, zip_stall, zip_err,
			zip_none_sel;
	reg		zip_many_ack;
	wire	[27:0]	zip_addr;
	wire	[31:0]	zip_data;
	reg	[31:0]	zip_idata;
	wire	[3:0]	zip_sel;
	reg		zip_ack;

	// Wishbone slave definitions for bus zip, slave zip_dwb
	wire		zip_dwb_sel, zip_dwb_ack, zip_dwb_stall, zip_dwb_err;
	wire	[31:0]	zip_dwb_data;

	// Bus wbu
	// Wishbone master wire definitions for bus: wbu
	wire		wbu_cyc, wbu_stb, wbu_we, wbu_stall, wbu_err,
			wbu_none_sel;
	reg		wbu_many_ack;
	wire	[28:0]	wbu_addr;
	wire	[31:0]	wbu_data;
	reg	[31:0]	wbu_idata;
	wire	[3:0]	wbu_sel;
	reg		wbu_ack;

	// Wishbone slave definitions for bus wbu, slave wbu_dwb
	wire		wbu_dwb_sel, wbu_dwb_ack, wbu_dwb_stall, wbu_dwb_err;
	wire	[31:0]	wbu_dwb_data;

	// Wishbone slave definitions for bus wbu, slave zip_dbg
	wire		zip_dbg_sel, zip_dbg_ack, zip_dbg_stall;
	wire	[31:0]	zip_dbg_data;

	// Bus vid
	// Wishbone master wire definitions for bus: vid
	wire		vid_cyc, vid_stb, vid_we, vid_stall, vid_err,
			vid_none_sel;
	reg		vid_many_ack;
	wire	[24:0]	vid_addr;
	wire	[127:0]	vid_data;
	reg	[127:0]	vid_idata;
	wire	[15:0]	vid_sel;
	reg		vid_ack;

	// Wishbone slave definitions for bus vid, slave vid_bus
	wire		vid_bus_sel, vid_bus_ack, vid_bus_stall, vid_bus_err;
	wire	[127:0]	vid_bus_data;

	// Bus sdr
	// Wishbone master wire definitions for bus: sdr
	wire		sdr_cyc, sdr_stb, sdr_we, sdr_stall, sdr_err,
			sdr_none_sel;
	reg		sdr_many_ack;
	wire	[24:0]	sdr_addr;
	wire	[127:0]	sdr_data;
	reg	[127:0]	sdr_idata;
	wire	[15:0]	sdr_sel;
	reg		sdr_ack;

	// Wishbone slave definitions for bus sdr, slave sdram
	wire		sdram_sel, sdram_ack, sdram_stall, sdram_err;;
	wire	[127:0]	sdram_data;

	// Bus xpand_bus
	// Wishbone master wire definitions for bus: xpand_bus
	wire		xpand_bus_cyc, xpand_bus_stb, xpand_bus_we, xpand_bus_stall, xpand_bus_err,
			xpand_bus_none_sel;
	reg		xpand_bus_many_ack;
	wire	[24:0]	xpand_bus_addr;
	wire	[127:0]	xpand_bus_data;
	reg	[127:0]	xpand_bus_idata;
	wire	[15:0]	xpand_bus_sel;
	reg		xpand_bus_ack;

	// Wishbone slave definitions for bus xpand_bus, slave sdram_arbiter
	wire		sdram_arbiter_sel, sdram_arbiter_ack, sdram_arbiter_stall, sdram_arbiter_err;
	wire	[127:0]	sdram_arbiter_data;


	//
	// Peripheral address decoding
	//
	//
	//
	//
	// Select lines for bus: wb
	//
	// Address width: 28
	// Data width:    32
	//
	//
	
	assign	   buildtime_sel = ((wb_sio_sel)&&(wb_addr[ 3: 0] ==  4'h0));
 // 0x0000000
	assign	      buserr_sel = ((wb_sio_sel)&&(wb_addr[ 3: 0] ==  4'h1));
 // 0x0000004
	assign	      buspic_sel = ((wb_sio_sel)&&(wb_addr[ 3: 0] ==  4'h2));
 // 0x0000008
	assign	   clkhdmiin_sel = ((wb_sio_sel)&&(wb_addr[ 3: 0] ==  4'h3));
 // 0x000000c
	assign	  clkhdmiout_sel = ((wb_sio_sel)&&(wb_addr[ 3: 0] ==  4'h4));
 // 0x0000010
	assign	      genclk_sel = ((wb_sio_sel)&&(wb_addr[ 3: 0] ==  4'h5));
 // 0x0000014
	assign	 genclk_test_sel = ((wb_sio_sel)&&(wb_addr[ 3: 0] ==  4'h6));
 // 0x0000018
	assign	        gpio_sel = ((wb_sio_sel)&&(wb_addr[ 3: 0] ==  4'h7));
 // 0x000001c
	assign	hdmi_scope_frame_offset_sel = ((wb_sio_sel)&&(wb_addr[ 3: 0] ==  4'h8));
 // 0x0000020
	assign	 netclockctr_sel = ((wb_sio_sel)&&(wb_addr[ 3: 0] ==  4'h9));
 // 0x0000024
	assign	    pwrcount_sel = ((wb_sio_sel)&&(wb_addr[ 3: 0] ==  4'ha));
 // 0x0000028
	assign	     rtcdate_sel = ((wb_sio_sel)&&(wb_addr[ 3: 0] ==  4'hb));
 // 0x000002c
	assign	        spio_sel = ((wb_sio_sel)&&(wb_addr[ 3: 0] ==  4'hc));
 // 0x0000030
	assign	  subseconds_sel = ((wb_sio_sel)&&(wb_addr[ 3: 0] ==  4'hd));
 // 0x0000034
	assign	      sysclk_sel = ((wb_sio_sel)&&(wb_addr[ 3: 0] ==  4'he));
 // 0x0000038
	assign	     version_sel = ((wb_sio_sel)&&(wb_addr[ 3: 0] ==  4'hf));
 // 0x000003c
	assign	         gck_sel = ((wb_dio_sel)&&((wb_addr[ 7: 3] &  5'h1f) ==  5'h00));
 // 0x0000000 - 0x000000f
	assign	        mous_sel = ((wb_dio_sel)&&((wb_addr[ 7: 3] &  5'h1f) ==  5'h01));
 // 0x0000020 - 0x000002f
	assign	         rtc_sel = ((wb_dio_sel)&&((wb_addr[ 7: 3] &  5'h1f) ==  5'h02));
 // 0x0000040 - 0x000004f
	assign	         gtb_sel = ((wb_dio_sel)&&((wb_addr[ 7: 3] &  5'h1f) ==  5'h03));
 // 0x0000060 - 0x000007f
	assign	      hdmiin_sel = ((wb_dio_sel)&&((wb_addr[ 7: 3] &  5'h1e) ==  5'h04));
 // 0x0000080 - 0x00000bf
	assign	        edin_sel = ((wb_dio_sel)&&((wb_addr[ 7: 3] &  5'h18) ==  5'h08));
 // 0x0000100 - 0x00001ff
	assign	       edout_sel = ((wb_dio_sel)&&((wb_addr[ 7: 3] &  5'h10) ==  5'h10));
 // 0x0000200 - 0x00003ff
	assign	   enetscope_sel = ((wb_addr[27:22] &  6'h3f) ==  6'h01); // 0x1000000 - 0x1000007
	assign	        pmic_sel = ((wb_addr[27:22] &  6'h3f) ==  6'h02); // 0x2000000 - 0x2000007
	assign	   scop_edid_sel = ((wb_addr[27:22] &  6'h3f) ==  6'h03); // 0x3000000 - 0x3000007
	assign	scope_hdmiin_sel = ((wb_addr[27:22] &  6'h3f) ==  6'h04); // 0x4000000 - 0x4000007
	assign	scope_sdcard_sel = ((wb_addr[27:22] &  6'h3f) ==  6'h05); // 0x5000000 - 0x5000007
	assign	    zipscope_sel = ((wb_addr[27:22] &  6'h3f) ==  6'h06); // 0x6000000 - 0x6000007
	assign	       flctl_sel = ((wb_addr[27:22] &  6'h3f) ==  6'h07); // 0x7000000 - 0x700000f
	assign	        gpsu_sel = ((wb_addr[27:22] &  6'h3f) ==  6'h08); // 0x8000000 - 0x800000f
	assign	      sdcard_sel = ((wb_addr[27:22] &  6'h3f) ==  6'h09); // 0x9000000 - 0x900000f
	assign	        uart_sel = ((wb_addr[27:22] &  6'h3f) ==  6'h0a); // 0xa000000 - 0xa00000f
	assign	        netp_sel = ((wb_addr[27:22] &  6'h3f) ==  6'h0b); // 0xb000000 - 0xb00001f
	assign	      wb_sio_sel = ((wb_addr[27:22] &  6'h3f) ==  6'h0c); // 0xc000000 - 0xc00003f
//x2	Was a master bus as well
	assign	         cfg_sel = ((wb_addr[27:22] &  6'h3f) ==  6'h0d); // 0xd000000 - 0xd00007f
	assign	        mdio_sel = ((wb_addr[27:22] &  6'h3f) ==  6'h0e); // 0xe000000 - 0xe00007f
	assign	      wb_dio_sel = ((wb_addr[27:22] &  6'h3f) ==  6'h0f); // 0xf000000 - 0xf0003ff
//x2	Was a master bus as well
	assign	        netb_sel = ((wb_addr[27:22] &  6'h3f) ==  6'h10); // 0x10000000 - 0x10007fff
	assign	       bkram_sel = ((wb_addr[27:22] &  6'h3f) ==  6'h11); // 0x11000000 - 0x110fffff
	assign	       flash_sel = ((wb_addr[27:22] &  6'h3f) ==  6'h12); // 0x12000000 - 0x12ffffff
	assign	       xpand_sel = ((wb_addr[27:22] &  6'h20) ==  6'h20); // 0x20000000 - 0x3fffffff
//x2	Was a master bus as well
	//

	//
	//
	//
	// Select lines for bus: zip
	//
	// Address width: 28
	// Data width:    32
	//
	//
	
	assign	     zip_dwb_sel = (zip_cyc); // Only one peripheral on this bus
	//

	//
	//
	//
	// Select lines for bus: wbu
	//
	// Address width: 29
	// Data width:    32
	//
	//
	
	assign	     wbu_dwb_sel = ((wbu_addr[28:27] &  2'h2) ==  2'h0); // 0x00000000 - 0x3fffffff
//x2	Was a master bus as well
	assign	     zip_dbg_sel = ((wbu_addr[28:27] &  2'h3) ==  2'h2); // 0x40000000 - 0x40000007
	//

	//
	//
	//
	// Select lines for bus: vid
	//
	// Address width: 25
	// Data width:    128
	//
	//
	
	assign	     vid_bus_sel = (vid_cyc); // Only one peripheral on this bus
	//

	//
	//
	//
	// Select lines for bus: sdr
	//
	// Address width: 25
	// Data width:    128
	//
	//
	
	assign	       sdram_sel = (sdr_cyc); // Only one peripheral on this bus
	//

	//
	//
	//
	// Select lines for bus: xpand_bus
	//
	// Address width: 25
	// Data width:    128
	//
	//
	
	assign	sdram_arbiter_sel = (xpand_bus_cyc); // Only one peripheral on this bus
	//

	//
	// BUS-LOGIC for wb
	//
	assign	wb_none_sel = (wb_stb)&&({
				enetscope_sel,
				pmic_sel,
				scop_edid_sel,
				scope_hdmiin_sel,
				scope_sdcard_sel,
				zipscope_sel,
				flctl_sel,
				gpsu_sel,
				sdcard_sel,
				uart_sel,
				netp_sel,
				wb_sio_sel,
				cfg_sel,
				mdio_sel,
				wb_dio_sel,
				netb_sel,
				bkram_sel,
				flash_sel,
				xpand_sel} == 0);

	//
	// many_ack
	//
	// It is also a violation of the bus protocol to produce multiple
	// acks at once and on the same clock.  In that case, the bus
	// can't decide which result to return.  Worse, if someone is waiting
	// for a return value, that value will never come since another ack
	// masked it.
	//
	// The other error that isn't tested for here, no would I necessarily
	// know how to test for it, is when peripherals return values out of
	// order.  Instead, I propose keeping that from happening by
	// guaranteeing, in software, that two peripherals are not accessed
	// immediately one after the other.
	//
	always @(posedge i_clk)
		case({		enetscope_ack,
				pmic_ack,
				scop_edid_ack,
				scope_hdmiin_ack,
				scope_sdcard_ack,
				zipscope_ack,
				flctl_ack,
				gpsu_ack,
				sdcard_ack,
				uart_ack,
				netp_ack,
				wb_sio_ack,
				cfg_ack,
				mdio_ack,
				wb_dio_ack,
				netb_ack,
				bkram_ack,
				flash_ack,
				xpand_ack})
			19'b0000000000000000000: wb_many_ack <= 1'b0;
			19'b1000000000000000000: wb_many_ack <= 1'b0;
			19'b0100000000000000000: wb_many_ack <= 1'b0;
			19'b0010000000000000000: wb_many_ack <= 1'b0;
			19'b0001000000000000000: wb_many_ack <= 1'b0;
			19'b0000100000000000000: wb_many_ack <= 1'b0;
			19'b0000010000000000000: wb_many_ack <= 1'b0;
			19'b0000001000000000000: wb_many_ack <= 1'b0;
			19'b0000000100000000000: wb_many_ack <= 1'b0;
			19'b0000000010000000000: wb_many_ack <= 1'b0;
			19'b0000000001000000000: wb_many_ack <= 1'b0;
			19'b0000000000100000000: wb_many_ack <= 1'b0;
			19'b0000000000010000000: wb_many_ack <= 1'b0;
			19'b0000000000001000000: wb_many_ack <= 1'b0;
			19'b0000000000000100000: wb_many_ack <= 1'b0;
			19'b0000000000000010000: wb_many_ack <= 1'b0;
			19'b0000000000000001000: wb_many_ack <= 1'b0;
			19'b0000000000000000100: wb_many_ack <= 1'b0;
			19'b0000000000000000010: wb_many_ack <= 1'b0;
			19'b0000000000000000001: wb_many_ack <= 1'b0;
			default: wb_many_ack <= (wb_cyc);
		endcase

	assign	wb_sio_stall = 1'b0;
	initial r_wb_sio_ack = 1'b0;
	always	@(posedge i_clk)
		r_wb_sio_ack <= (wb_stb)&&(wb_sio_sel);
	assign	wb_sio_ack = r_wb_sio_ack;
	reg	r_wb_sio_ack;
	reg	[31:0]	r_wb_sio_data;
	always	@(posedge i_clk)
		// mask        = 0000000f
		// lgdw        = 2
		// unused_lsbs = 0
		casez( wb_addr[3:0] )
			4'h0: r_wb_sio_data <= buildtime_data;
			4'h1: r_wb_sio_data <= buserr_data;
			4'h2: r_wb_sio_data <= buspic_data;
			4'h3: r_wb_sio_data <= clkhdmiin_data;
			4'h4: r_wb_sio_data <= clkhdmiout_data;
			4'h5: r_wb_sio_data <= genclk_data;
			4'h6: r_wb_sio_data <= genclk_test_data;
			4'h7: r_wb_sio_data <= gpio_data;
			4'h8: r_wb_sio_data <= hdmi_scope_frame_offset_data;
			4'h9: r_wb_sio_data <= netclockctr_data;
			4'ha: r_wb_sio_data <= pwrcount_data;
			4'hb: r_wb_sio_data <= rtcdate_data;
			4'hc: r_wb_sio_data <= spio_data;
			4'hd: r_wb_sio_data <= subseconds_data;
			4'he: r_wb_sio_data <= sysclk_data;
			default: r_wb_sio_data <= version_data;
		endcase
	assign	wb_sio_data = r_wb_sio_data;

	assign	wb_dio_stall = 1'b0;
	reg	[1:0]	r_wb_dio_ack;
	always	@(posedge i_clk)
		r_wb_dio_ack <= { r_wb_dio_ack[0], (wb_stb)&&(wb_dio_sel) };
	assign	wb_dio_ack = r_wb_dio_ack[1];
	reg	[31:0]	r_wb_dio_data;
	always	@(posedge i_clk)
		casez({		gck_ack,
				mous_ack,
				rtc_ack,
				gtb_ack,
				hdmiin_ack,
				edin_ack	}) // edout default
			6'b1?????: r_wb_dio_data <= gck_data;
			6'b01????: r_wb_dio_data <= mous_data;
			6'b001???: r_wb_dio_data <= rtc_data;
			6'b0001??: r_wb_dio_data <= gtb_data;
			6'b00001?: r_wb_dio_data <= hdmiin_data;
			6'b000001: r_wb_dio_data <= edin_data;
			default: r_wb_dio_data <= edout_data;

		endcase
	assign	wb_dio_data = r_wb_dio_data;

	//
	// Finally, determine what the response is from the wb bus
	// bus
	//
	//
	//
	// wb_ack
	//
	// The returning wishbone ack is equal to the OR of every component that
	// might possibly produce an acknowledgement, gated by the CYC line.
	//
	// To return an ack here, a component must have a @SLAVE.TYPE tag.
	// Acks from any @SLAVE.TYPE of SINGLE and DOUBLE components have been
	// collected together (above) into wb_sio_ack and wb_dio_ack
	// respectively, which will appear ahead of any other device acks.
	//
	always @(posedge i_clk)
		wb_ack <= (wb_cyc)&&(|{ enetscope_ack,
				pmic_ack,
				scop_edid_ack,
				scope_hdmiin_ack,
				scope_sdcard_ack,
				zipscope_ack,
				flctl_ack,
				gpsu_ack,
				sdcard_ack,
				uart_ack,
				netp_ack,
				wb_sio_ack,
				cfg_ack,
				mdio_ack,
				wb_dio_ack,
				netb_ack,
				bkram_ack,
				flash_ack,
				xpand_ack });
	//
	// wb_idata
	//
	// This is the data returned on the bus.  Here, we select between a
	// series of bus sources to select what data to return.  The basic
	// logic is simply this: the data we return is the data for which the
	// ACK line is high.
	//
	// The last item on the list is chosen by default if no other ACK's are
	// true.  Although we might choose to return zeros in that case, by
	// returning something we can skimp a touch on the logic.
	//
	// Any peripheral component with a @SLAVE.TYPE value will be listed
	// here.
	//
	always @(posedge i_clk)
	begin
		casez({		enetscope_ack,
				pmic_ack,
				scop_edid_ack,
				scope_hdmiin_ack,
				scope_sdcard_ack,
				zipscope_ack,
				flctl_ack,
				gpsu_ack,
				sdcard_ack,
				uart_ack,
				netp_ack,
				wb_sio_ack,
				cfg_ack,
				mdio_ack,
				wb_dio_ack,
				netb_ack,
				bkram_ack,
				flash_ack	})
			18'b1?????????????????: wb_idata <= enetscope_data;
			18'b01????????????????: wb_idata <= pmic_data;
			18'b001???????????????: wb_idata <= scop_edid_data;
			18'b0001??????????????: wb_idata <= scope_hdmiin_data;
			18'b00001?????????????: wb_idata <= scope_sdcard_data;
			18'b000001????????????: wb_idata <= zipscope_data;
			18'b0000001???????????: wb_idata <= flctl_data;
			18'b00000001??????????: wb_idata <= gpsu_data;
			18'b000000001?????????: wb_idata <= sdcard_data;
			18'b0000000001????????: wb_idata <= uart_data;
			18'b00000000001???????: wb_idata <= netp_data;
			18'b000000000001??????: wb_idata <= wb_sio_data;
			18'b0000000000001?????: wb_idata <= cfg_data;
			18'b00000000000001????: wb_idata <= mdio_data;
			18'b000000000000001???: wb_idata <= wb_dio_data;
			18'b0000000000000001??: wb_idata <= netb_data;
			18'b00000000000000001?: wb_idata <= bkram_data;
			18'b000000000000000001: wb_idata <= flash_data;
			default: wb_idata <= xpand_data;
		endcase
	end
	assign	wb_stall =	((enetscope_sel)&&(enetscope_stall))
				||((pmic_sel)&&(pmic_stall))
				||((scop_edid_sel)&&(scop_edid_stall))
				||((scope_hdmiin_sel)&&(scope_hdmiin_stall))
				||((scope_sdcard_sel)&&(scope_sdcard_stall))
				||((zipscope_sel)&&(zipscope_stall))
				||((flctl_sel)&&(flctl_stall))
				||((gpsu_sel)&&(gpsu_stall))
				||((sdcard_sel)&&(sdcard_stall))
				||((uart_sel)&&(uart_stall))
				||((netp_sel)&&(netp_stall))
				||((wb_sio_sel)&&(wb_sio_stall))
				||((cfg_sel)&&(cfg_stall))
				||((mdio_sel)&&(mdio_stall))
				||((wb_dio_sel)&&(wb_dio_stall))
				||((netb_sel)&&(netb_stall))
				||((bkram_sel)&&(bkram_stall))
				||((flash_sel)&&(flash_stall))
				||((xpand_sel)&&(xpand_stall));

	assign wb_err = ((wb_stb)&&(wb_none_sel))||(wb_many_ack)||((xpand_err));
	//
	// BUS-LOGIC for zip
	//
	assign	zip_none_sel = 1'b0;
	always @(*)
		zip_many_ack = 1'b0;
	assign	zip_err = zip_dwb_err;
	assign	zip_stall = zip_dwb_stall;
	always @(*)
		zip_ack = zip_dwb_ack;
	always @(*)
		zip_idata = zip_dwb_data;
	//
	// BUS-LOGIC for wbu
	//
	assign	wbu_none_sel = (wbu_stb)&&({
				wbu_dwb_sel,
				zip_dbg_sel} == 0);

	//
	// many_ack
	//
	// It is also a violation of the bus protocol to produce multiple
	// acks at once and on the same clock.  In that case, the bus
	// can't decide which result to return.  Worse, if someone is waiting
	// for a return value, that value will never come since another ack
	// masked it.
	//
	// The other error that isn't tested for here, no would I necessarily
	// know how to test for it, is when peripherals return values out of
	// order.  Instead, I propose keeping that from happening by
	// guaranteeing, in software, that two peripherals are not accessed
	// immediately one after the other.
	//
	always @(posedge i_clk)
		case({		wbu_dwb_ack,
				zip_dbg_ack})
			2'b00: wbu_many_ack <= 1'b0;
			2'b10: wbu_many_ack <= 1'b0;
			2'b01: wbu_many_ack <= 1'b0;
			default: wbu_many_ack <= (wbu_cyc);
		endcase

	//
	// Finally, determine what the response is from the wbu bus
	// bus
	//
	//
	//
	// wbu_ack
	//
	// The returning wishbone ack is equal to the OR of every component that
	// might possibly produce an acknowledgement, gated by the CYC line.
	//
	// To return an ack here, a component must have a @SLAVE.TYPE tag.
	// Acks from any @SLAVE.TYPE of SINGLE and DOUBLE components have been
	// collected together (above) into wbu_sio_ack and wbu_dio_ack
	// respectively, which will appear ahead of any other device acks.
	//
	always @(posedge i_clk)
		wbu_ack <= (wbu_cyc)&&(|{ wbu_dwb_ack,
				zip_dbg_ack });
	//
	// wbu_idata
	//
	// This is the data returned on the bus.  Here, we select between a
	// series of bus sources to select what data to return.  The basic
	// logic is simply this: the data we return is the data for which the
	// ACK line is high.
	//
	// The last item on the list is chosen by default if no other ACK's are
	// true.  Although we might choose to return zeros in that case, by
	// returning something we can skimp a touch on the logic.
	//
	// Any peripheral component with a @SLAVE.TYPE value will be listed
	// here.
	//
	always @(posedge i_clk)
		if (wbu_dwb_ack)
			wbu_idata <= wbu_dwb_data;
		else
			wbu_idata <= zip_dbg_data;
	assign	wbu_stall =	((wbu_dwb_sel)&&(wbu_dwb_stall))
				||((zip_dbg_sel)&&(zip_dbg_stall));

	assign wbu_err = ((wbu_stb)&&(wbu_none_sel))||(wbu_many_ack)||((wbu_dwb_err));
	//
	// BUS-LOGIC for vid
	//
	assign	vid_none_sel = 1'b0;
	always @(*)
		vid_many_ack = 1'b0;
	assign	vid_err = vid_bus_err;
	assign	vid_stall = vid_bus_stall;
	always @(*)
		vid_ack = vid_bus_ack;
	always @(*)
		vid_idata = vid_bus_data;
	//
	// BUS-LOGIC for sdr
	//
	assign	sdr_none_sel = 1'b0;
	always @(*)
		sdr_many_ack = 1'b0;
	assign	sdr_err = sdram_err;;
	assign	sdr_stall = sdram_stall;
	always @(*)
		sdr_ack = sdram_ack;
	always @(*)
		sdr_idata = sdram_data;
	//
	// BUS-LOGIC for xpand_bus
	//
	assign	xpand_bus_none_sel = 1'b0;
	always @(*)
		xpand_bus_many_ack = 1'b0;
	assign	xpand_bus_err = sdram_arbiter_err;
	assign	xpand_bus_stall = sdram_arbiter_stall;
	always @(*)
		xpand_bus_ack = sdram_arbiter_ack;
	always @(*)
		xpand_bus_idata = sdram_arbiter_data;
	//
	// Declare the interrupt busses
	//
	// Interrupt busses are defined by anything with a @PIC tag.
	// The @PIC.BUS tag defines the name of the wire bus below,
	// while the @PIC.MAX tag determines the size of the bus width.
	//
	// For your peripheral to be assigned to this bus, it must have an
	// @INT.NAME.WIRE= tag to define the wire name of the interrupt line,
	// and an @INT.NAME.PIC= tag matching the @PIC.BUS tag of the bus
	// your interrupt will be assigned to.  If an @INT.NAME.ID tag also
	// exists, then your interrupt will be assigned to the position given
	// by the ID# in that tag.
	//
	assign	sys_int_vector = {
		uartrxf_int,
		uarttxf_int,
		sdcard_int,
		pmic_int,
		mous_interrupt,
		netrx_int,
		nettx_int,
		ck_pps,
		w_bus_int,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0
	};
	assign	alt_int_vector = {
		rtc_int,
		gpsutxf_int,
		gpsurxf_int,
		gpsutx_int,
		gpsurx_int,
		gpio_int,
		edid_out_int,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0
	};
	assign	bus_int_vector = {
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		1'b0,
		spio_int,
		sdcard_int,
		scop_hdmiin_int,
		zipscope_int,
		mous_interrupt,
		flash_interrupt,
		enetscope_int,
		scop_edid_int
	};


	//
	//
	// Now we turn to defining all of the parts and pieces of what
	// each of the various peripherals does, and what logic it needs.
	//
	// This information comes from the @MAIN.INSERT and @MAIN.ALT tags.
	// If an @ACCESS tag is available, an ifdef is created to handle
	// having the access and not.  If the @ACCESS tag is `defined above
	// then the @MAIN.INSERT code is executed.  If not, the @MAIN.ALT
	// code is exeucted, together with any other cleanup settings that
	// might need to take place--such as returning zeros to the bus,
	// or making sure all of the various interrupt wires are set to
	// zero if the component is not included.
	//
	clkcounter clksysclkctr(i_clk, ck_pps, i_clk, sysclk_data);
	always @(posedge i_clk)
		r_sysclk_ack <= (wb_stb)&&(sysclk_sel);
	assign	sysclk_ack   = r_sysclk_ack;
	assign	sysclk_stall = 1'b0;
`ifdef	HDMI_OUT_EDID_ACCESS
	wbi2cmaster	#(.READ_ONLY(1'b1),.MEM_ADDR_BITS(8)) the_edout(i_clk,
		wb_cyc, (wb_stb)&&(edout_sel), wb_we, wb_addr[6:0], wb_data,
			wb_sel, edout_ack, edout_stall, edout_data,
		i_hdmi_out_scl, i_hdmi_out_sda, o_hdmi_out_scl, o_hdmi_out_sda,
		edid_out_int,
		edido_dbg);
`else	// HDMI_OUT_EDID_ACCESS
	assign	o_hdmi_out_scl = 1'b1;
	assign	o_hdmi_out_sda = 1'b1;

	// In the case that there is no edout peripheral responding on the wb bus
	reg	r_edout_ack;
	initial	r_edout_ack = 1'b0;
	always @(posedge i_clk)	r_edout_ack <= (wb_stb)&&(edout_sel);
	assign	edout_ack   = r_edout_ack;
	assign	edout_stall = 0;
	assign	edout_data  = 0;

	assign	edid_out_int = 1'b0;	// edout.INT.EDID.WIRE
`endif	// HDMI_OUT_EDID_ACCESS

	assign	edid_scope_trigger = edido_dbg[31];
	assign	edid_scope_data    = edido_dbg[30:0];
	wbscopc	#(.LGMEM(5'hb), .MAX_STEP(31'h10000)) theicscop(i_clk, 1'b1,
			edid_scope_trigger, edid_scope_data,
			i_clk, wb_cyc, (wb_stb)&&(scop_edid_sel), wb_we, wb_addr[0], wb_data,
			scop_edid_ack, scop_edid_stall, scop_edid_data,
			scop_edid_int);
	clkcounter clkclkhdmiinctr(i_clk, ck_pps, i_hdmi_in_clk, clkhdmiin_data);
	always @(posedge i_clk)
		r_clkhdmiin_ack <= (wb_stb)&&(clkhdmiin_sel);
	assign	clkhdmiin_ack   = r_clkhdmiin_ack;
	assign	clkhdmiin_stall = 1'b0;
	clkcounter clkclkhdmioutctr(i_clk, ck_pps, i_clk_200mhz, clkhdmiout_data);
	always @(posedge i_clk)
		r_clkhdmiout_ack <= (wb_stb)&&(clkhdmiout_sel);
	assign	clkhdmiout_ack   = r_clkhdmiout_ack;
	assign	clkhdmiout_stall = 1'b0;
`ifdef	GPSTRK_ACCESS
	wire	[1:0]	ck_dbg;

	gpsclock #(.DEFAULT_STEP(GPSCLOCK_DEFAULT_STEP))
		ppsck(i_clk, 1'b0, gps_pps, ck_pps, gps_led,
			(wb_stb)&&(gck_sel), wb_we, wb_addr[1:0], wb_data,
				gck_ack, gck_stall, gck_data,
			gps_tracking, gps_now, gps_step, gps_err, gps_locked,
			ck_dbg);
`else	// GPSTRK_ACCESS
	wire	[31:0]	pre_step;
	assign	pre_step = { 16'h00, (({GPSCLOCK_DEFAULT_STEP[27:0],20'h00})
				>>GPSCLOCK_DEFAULT_STEP[31:28]) };
	always @(posedge i_clk)
		{ ck_pps, gps_step[31:0] } <= gps_step + pre_step;
	assign	gck_stall  = 1'b0;
	assign	gps_now    = 64'h0;
	assign	gps_err    = 64'h0;
	assign	gps_step   = 64'h0;
	assign	gps_led    = 1'b0;
	assign	gps_locked = 1'b0;


	// In the case that there is no gck peripheral responding on the wb bus
	reg	r_gck_ack;
	initial	r_gck_ack = 1'b0;
	always @(posedge i_clk)	r_gck_ack <= (wb_stb)&&(gck_sel);
	assign	gck_ack   = r_gck_ack;
	assign	gck_stall = 0;
	assign	gck_data  = 0;

	assign	ck_pps = 1'b0;	// gck.INT.PPS.WIRE
`endif	// GPSTRK_ACCESS

`ifdef	GPSTRK_ACCESS
	gpsclock_tb #(.CLOCK_FREQUENCY_HZ(100000000))
		ppstb(i_clk, ck_pps, tb_pps,
			(wb_stb)&&(gtb_sel), wb_we, wb_addr[2:0], wb_data,
				gtb_ack, gtb_stall, gtb_data,
			gps_err, gps_now, gps_step);

`ifdef	GPSTB
	assign	gps_pps = tb_pps;
`else
	assign	gps_pps = i_gps_pps;
`endif

`endif

	assign	o_hdmi_out_r = hdmi_in_r;
	assign	o_hdmi_out_g = hdmi_in_g;
	assign	o_hdmi_out_b = hdmi_in_b;

`ifdef	NETSCOPE_SCOPE
   	wbscope #(.LGMEM(9),
		.SYNCHRONOUS(0))
	enetscopei(i_net_rx_clk, 1'b1, netp_dbg_trigger, netp_debug,
		i_clk, wb_cyc, (wb_stb)&&(enetscope_sel), wb_we,
		wb_addr[0], wb_data, enetscope_ack, enetscope_stall,
		enetscope_data, enetscope_int);


	assign	netp_dbg_trigger = netp_debug[31];
`else	// NETSCOPE_SCOPE
	assign	enetscope_int = 0;

	// In the case that there is no enetscope peripheral responding on the wb bus
	reg	r_enetscope_ack;
	initial	r_enetscope_ack = 1'b0;
	always @(posedge i_clk)	r_enetscope_ack <= (wb_stb)&&(enetscope_sel);
	assign	enetscope_ack   = r_enetscope_ack;
	assign	enetscope_stall = 0;
	assign	enetscope_data  = 0;

	assign	enetscope_int = 1'b0;	// enetscope.INT.ENETSCOPE.WIRE
`endif	// NETSCOPE_SCOPE

`ifndef	ETHERNET_ACCESS
	// Ethernet packet memory declaration
	//
	// The only time this needs to be defined is when the ethernet module
	// itself isnt defined.  Otherwise, the access is accomplished by the
	// ethernet module

	memdev #(14)
		enet_buffers(i_clk,
			(wb_cyc), (wb_stb)&&(netb_sel),
				(wb_we)&&(wb_addr[14-1]),
				wb_addr[14-2:0], wb_data, wb_sel,
				netb_ack, netb_stall, netb_data);

`else

	assign	netb_ack   = 1'b0;
	assign	netb_stall = 1'b0;
	assign	netb_data  = 0;

`endif

`ifdef	ETHERNET_ACCESS
	assign	o_net_tx_clk = i_net_rx_clk;
	enetpackets	#(.MEMORY_ADDRESS_WIDTH(14))
		netctrl(i_clk, i_reset,
			wb_cyc,(wb_stb)&&((netp_sel)||(netb_sel)),
			wb_we, { (netb_sel), wb_addr[14-2:0] }, wb_data, wb_sel,
				netp_ack, netp_stall, netp_data,
			o_net_reset_n,
			i_net_rx_clk, i_net_rx_ctl, i_net_rxd,
			o_net_tx_clk, o_net_tx_ctl, o_net_txd,
			netrx_int, nettx_int, netp_debug);

`else	// ETHERNET_ACCESS

	// In the case that there is no netp peripheral responding on the wb bus
	reg	r_netp_ack;
	initial	r_netp_ack = 1'b0;
	always @(posedge i_clk)	r_netp_ack <= (wb_stb)&&(netp_sel);
	assign	netp_ack   = r_netp_ack;
	assign	netp_stall = 0;
	assign	netp_data  = 0;

	assign	nettx_int = 1'b0;	// netp.INT.NETTX.WIRE
	assign	netrx_int = 1'b0;	// netp.INT.NETRX.WIRE
`endif	// ETHERNET_ACCESS

`ifdef	INCLUDE_ZIPCPU
	//
	//
	// The ZipCPU/ZipSystem BUS master
	//
	//
	assign	zip_int_vector = { alt_int_vector[14:8], sys_int_vector[14:6] };
	zipsystem #(RESET_ADDRESS,ZIP_ADDRESS_WIDTH,10,0,
			ZIP_START_HALTED,ZIP_INTS)
		swic(i_clk, (i_reset)||(i_cpu_reset),
			// Zippys wishbone interface
			zip_cyc, zip_stb, zip_we, zip_addr, zip_data, zip_sel,
					zip_ack, zip_stall, zip_idata, zip_err,
			zip_int_vector, zip_cpu_int,
			// Debug wishbone interface
			(wbu_cyc), ((wbu_stb)&&(zip_dbg_sel)),wbu_we,
			wbu_addr[0],
			wbu_data, zip_dbg_ack, zip_dbg_stall, zip_dbg_data,
			zip_debug);
	assign	zip_trigger = zip_debug[31];
`else	// INCLUDE_ZIPCPU

	// In the case that nothing drives the zip bus ...
	assign	zip_cyc = 1'b0;
	assign	zip_stb = 1'b0;
	assign	zip_we  = 1'b0;
	assign	zip_sel = 0;
	assign	zip_addr= 0;
	assign	zip_data= 0;
	// verilator lint_off UNUSED
	wire	[35:0]	unused_bus_zip;
	assign	unused_bus_zip = { zip_ack, zip_stall, zip_err, zip_data };
	// verilator lint_on  UNUSED

	assign	zip_cpu_int = 1'b0;	// zip.INT.ZIP.WIRE
`endif	// INCLUDE_ZIPCPU

	assign	version_data = `DATESTAMP;
	assign	version_ack = wb_stb && version_sel;
	assign	version_stall = 1'b0;
`ifdef	FLASH_ACCESS
	wbqspiflash #(24)
		flashmem(i_clk,
			(wb_cyc), (wb_stb)&&(flash_sel), (wb_stb)&&(flctl_sel),wb_we,
			wb_addr[(24-3):0], wb_data,
			flash_ack, flash_stall, flash_data,
			o_qspi_sck, o_qspi_cs_n, o_qspi_mod, o_qspi_dat, i_qspi_dat,
			flash_interrupt);
`else	// FLASH_ACCESS
	assign	o_qspi_sck  = 1'b1;
	assign	o_qspi_cs_n = 1'b1;
	assign	o_qspi_mod  = 2'b01;
	assign	o_qspi_dat  = 4'b1111;

	// In the case that there is no flash peripheral responding on the wb bus
	reg	r_flash_ack;
	initial	r_flash_ack = 1'b0;
	always @(posedge i_clk)	r_flash_ack <= (wb_stb)&&(flash_sel);
	assign	flash_ack   = r_flash_ack;
	assign	flash_stall = 0;
	assign	flash_data  = 0;

	assign	flash_interrupt = 1'b0;	// flash.INT.FLASH.WIRE
`endif	// FLASH_ACCESS

	assign	buildtime_data = `BUILDTIME;
	assign	buildtime_ack = wb_stb && buildtime_sel;
	assign	buildtime_stall = 1'b0;
	clkcounter clkgenclk_testctr(i_clk, ck_pps, i_genclk_clk, genclk_test_data);
	always @(posedge i_clk)
		r_genclk_test_ack <= (wb_stb)&&(genclk_test_sel);
	assign	genclk_test_ack   = r_genclk_test_ack;
	assign	genclk_test_stall = 1'b0;
`ifdef	INCLUDE_ZIPCPU
	//
	//
	// And an arbiter to decide who gets access to the bus
	//
	//
	// Clock speed = 100000000 Hz
	wbpriarbiter #(32,28)	bus_arbiter(i_clk,
		// The Zip CPU bus master --- gets the priority slot
		zip_cyc, (zip_stb)&&(zip_dwb_sel), zip_we, zip_addr, zip_data, zip_sel,
			zip_dwb_ack, zip_dwb_stall, zip_dwb_err,
		// The UART interface master
		(wbu_cyc),
			(wbu_stb)&&(wbu_dwb_sel),
			wbu_we,
			wbu_addr[(28-1):0],
			wbu_data, wbu_sel,
			wbu_dwb_ack, wbu_dwb_stall, wbu_dwb_err,
		// Common bus returns
		wbu_dwbi_cyc, wbu_dwbi_stb, wbu_dwbi_we, wbu_dwbi_addr, wbu_dwbi_odata, wbu_dwbi_sel,
			wbu_dwbi_ack, wbu_dwbi_stall, wbu_dwbi_err);

	// And because the ZipCPU and the Arbiter can create an unacceptable
	// delay, we often fail timing.  So, we add in a delay cycle
`else
	// If no ZipCPU, no delay arbiter is needed
	assign	wbu_dwbi_cyc   = wbu_cyc;
	assign	wbu_dwbi_stb   = wbu_stb;
	assign	wbu_dwbi_we    = wbu_we;
	assign	wbu_dwbi_addr  = wbu_addr;
	assign	wbu_dwbi_odata = wbu_data;
	assign	wbu_dwbi_sel   = wbu_sel;
	assign	wbu_dwb_ack    = wbu_dwbi_ack;
	assign	wbu_dwb_stall  = wbu_dwbi_stall;
	assign	wbu_dwb_err    = wbu_dwbi_err;
	assign	wbu_dwb_data   = wbu_dwbi_idata;
`endif	// INCLUDE_ZIPCPU

`ifdef	WBUBUS_MASTER
`ifdef	INCLUDE_ZIPCPU
`define	BUS_DELAY_NEEDED
`endif
`endif
`ifdef	BUS_DELAY_NEEDED
	busdelay #(28)	wbu_dwbi_delay(i_clk, i_reset,
		wbu_dwbi_cyc, wbu_dwbi_stb, wbu_dwbi_we, wbu_dwbi_addr, wbu_dwbi_odata, wbu_dwbi_sel,
			wbu_dwbi_ack, wbu_dwbi_stall, wbu_dwbi_idata, wbu_dwbi_err,
		wb_cyc, wb_stb, wb_we, wb_addr, wb_data, wb_sel,
			wb_ack, wb_stall, wb_idata, wb_err);
`else
	// If one of the two, the ZipCPU or the WBUBUS, isn't here, then we
	// don't need the bus delay, and we can go directly from the bus driver
	// to the bus itself
	//
	assign	wb_cyc    = wbu_dwbi_cyc;
	assign	wb_stb    = wbu_dwbi_stb;
	assign	wb_we     = wbu_dwbi_we;
	assign	wb_addr   = wbu_dwbi_addr;
	assign	wb_data   = wbu_dwbi_odata;
	assign	wb_sel    = wbu_dwbi_sel;
	assign	wbu_dwbi_ack   = wb_ack;
	assign	wbu_dwbi_stall = wb_stall;
	assign	wbu_dwbi_err   = wb_err;
	assign	wbu_dwbi_idata = wb_idata;
`endif
	assign	wbu_dwb_data = wbu_dwbi_idata;
`ifdef	INCLUDE_ZIPCPU
	assign	zip_dwb_data = wbu_dwbi_idata;
`endif
`ifdef	HDMIIN_ACCESS
	// HDMI input processor
	hdmiin	thehdmiin(i_clk, i_hdmi_in_clk, ck_pps,
			//
			i_hdmi_in_actual_delay_r,
			i_hdmi_in_actual_delay_g,
			i_hdmi_in_actual_delay_b,
			o_hdmi_in_delay,
			//
			i_hdmi_in_r, i_hdmi_in_g, i_hdmi_in_b,
			wb_cyc, (wb_stb)&&(hdmiin_sel), wb_we, wb_addr[3:0],
				wb_data, wb_sel,
			hdmiin_ack, hdmiin_stall, hdmiin_data,
			vid_cyc, vid_stb, vid_we,
				vid_addr, vid_data, vid_sel,
				vid_ack, vid_stall, vid_err,
			hdmiin_int,
			hin_pixels, hin_dbg_scope);

	assign	hdmi_in_r = hin_pixels[29:20];
	assign	hdmi_in_g = hin_pixels[19:10];
	assign	hdmi_in_b = hin_pixels[ 9: 0];
`else	// HDMIIN_ACCESS

	// In the case that nothing drives the vid bus ...
	assign	vid_cyc = 1'b0;
	assign	vid_stb = 1'b0;
	assign	vid_we  = 1'b0;
	assign	vid_sel = 0;
	assign	vid_addr= 0;
	assign	vid_data= 0;
	// verilator lint_off UNUSED
	wire	[131:0]	unused_bus_vid;
	assign	unused_bus_vid = { vid_ack, vid_stall, vid_err, vid_data };
	// verilator lint_on  UNUSED


	// In the case that there is no hdmiin peripheral responding on the wb bus
	reg	r_hdmiin_ack;
	initial	r_hdmiin_ack = 1'b0;
	always @(posedge i_clk)	r_hdmiin_ack <= (wb_stb)&&(hdmiin_sel);
	assign	hdmiin_ack   = r_hdmiin_ack;
	assign	hdmiin_stall = 0;
	assign	hdmiin_data  = 0;

	assign	hdmiin_int = 1'b0;	// hdmiin.INT.VSYNC.WIRE
`endif	// HDMIIN_ACCESS

`ifdef	GPSTRK_ACCESS
	assign	subseconds_data = gps_now[31:0];
`else
	always @(posedge i_clk)
	if ((wb_stb)&&(subseconds_sel))
		r_subseconds_data <= wb_data;
	else
		r_subseconds_data <= r_subseconds_data
			+ { 16'h0, RTLCLKSTEP[31:16] };

	assign	subseconds_data = r_subseconds_data;
`endif
`ifdef	ARBITRARY_CLOCK_GENERATOR_ACCESS
	initial	r_genclk_data = 31'd20;
	always @(posedge i_clk)
		if ((wb_stb)&&(wb_we)&&(genclk_sel))
			r_genclk_data <= wb_data[30:0];
	always @(posedge i_clk)
		r_genclk_ack <= ((wb_stb)&&(wb_we)&&(genclk_sel));
	assign	genclk_ack   = r_genclk_ack;
	assign	genclk_stall = 1'b0;
	assign	genclk_data = { i_genclk_pll_locked, r_genclk_data };
	assign	o_genclk_ce = r_genclk_data[30];

	genclk	clock_generator(i_clk,
			{ 2'b00, r_genclk_data[29:0] },
			o_genclk_word,
			w_genclk_stb);
`else	// ARBITRARY_CLOCK_GENERATOR_ACCESS

	// In the case that there is no genclk peripheral responding on the wb bus
	reg	r_genclk_ack;
	initial	r_genclk_ack = 1'b0;
	always @(posedge i_clk)	r_genclk_ack <= (wb_stb)&&(genclk_sel);
	assign	genclk_ack   = r_genclk_ack;
	assign	genclk_stall = 0;
	assign	genclk_data  = 0;

`endif	// ARBITRARY_CLOCK_GENERATOR_ACCESS

`ifdef	MOUSE_ACCESS
	wbmouse themouse(i_clk,
		(wb_cyc), (wb_stb)&&(mous_sel), wb_we, wb_addr[1:0], wb_data,
			mous_ack, mous_stall, mous_data,
		i_ps2, o_ps2,
		scrn_mouse, mous_interrupt);
`else	// MOUSE_ACCESS
	// If there is no mouse, declare mouse types of things to be .. absent
	assign	scrn_mouse     = 32'h00;
	assign	o_ps2          = 2'b11;

	// In the case that there is no mous peripheral responding on the wb bus
	reg	r_mous_ack;
	initial	r_mous_ack = 1'b0;
	always @(posedge i_clk)	r_mous_ack <= (wb_stb)&&(mous_sel);
	assign	mous_ack   = r_mous_ack;
	assign	mous_stall = 0;
	assign	mous_data  = 0;

	assign	mous_interrupt = 1'b0;	// mous.INT.MOUSE.WIRE
`endif	// MOUSE_ACCESS

`ifdef	HDMI_IN_EDID_ACCESS
	wbi2cslave	#( .INITIAL_MEM("edid.hex"),
		.I2C_READ_ONLY(1'b1),
		.MEM_ADDR_BITS(8))
	    the_input_edid(i_clk, 1'b0,
		wb_cyc, (wb_stb)&&(edin_sel), wb_we, wb_addr[8-3:0], wb_data,
			wb_sel, edin_ack, edin_stall, edin_data,
		i_hdmi_in_scl, i_hdmi_in_sda, o_hdmi_in_scl, o_hdmi_in_sda,
		edid_dbg);
`else	// HDMI_IN_EDID_ACCESS
	assign	o_hdmi_in_scl = 1'b1;
	assign	o_hdmi_in_sda = 1'b1;

	// In the case that there is no edin peripheral responding on the wb bus
	reg	r_edin_ack;
	initial	r_edin_ack = 1'b0;
	always @(posedge i_clk)	r_edin_ack <= (wb_stb)&&(edin_sel);
	assign	edin_ack   = r_edin_ack;
	assign	edin_stall = 0;
	assign	edin_data  = 0;

`endif	// HDMI_IN_EDID_ACCESS

	wbscope #(.LGMEM(9), .SYNCHRONOUS(1)) zipscopei(
		i_clk, 1'b1, zip_trigger, zip_debug,
		i_clk, wb_cyc,
		  ((wb_stb)&&(zipscope_sel)), wb_we, wb_addr[0], wb_data,
		zipscope_ack, zipscope_stall, zipscope_data,
		zipscope_int);
`ifdef	SDSPI_SCOPE
	assign	scope_sdcard_trigger = (wb_stb)
				&&(sdcard_sel)&&(wb_we);
	assign	scope_sdcard_ce = 1'b1;
	wbscope #(5'h9) sdspiscope(i_clk, scope_sdcard_ce,
			scope_sdcard_trigger,
			sdspi_debug,
			i_clk, wb_cyc,
			(wb_stb)&&(scope_sdcard_sel),
			wb_we,
			wb_addr[0],
			wb_data,
			scope_sdcard_ack,
			scope_sdcard_stall,
			scope_sdcard_data,
			scope_sdcard_int);

`else	// SDSPI_SCOPE

	// In the case that there is no scope_sdcard peripheral responding on the wb bus
	reg	r_scope_sdcard_ack;
	initial	r_scope_sdcard_ack = 1'b0;
	always @(posedge i_clk)	r_scope_sdcard_ack <= (wb_stb)&&(scope_sdcard_sel);
	assign	scope_sdcard_ack   = r_scope_sdcard_ack;
	assign	scope_sdcard_stall = 0;
	assign	scope_sdcard_data  = 0;

	assign	scope_sdcard_int = 1'b0;	// scope_sdcard.INT.SDSCOPE.WIRE
`endif	// SDSPI_SCOPE

`ifdef	WBUBUS_MASTER
	localparam	DBGBUSBITS = $clog2(BUSUART);
	// The Host USB interface, to be used by the WB-UART bus
	rxuartlite	#(.TIMER_BITS(DBGBUSBITS),
				.CLOCKS_PER_BAUD(BUSUART[DBGBUSBITS-1:0]))
		rcv(i_clk, i_wbu_uart_rx,
				wbu_rx_stb, wbu_rx_data);
	txuartlite	#(.TIMING_BITS(DBGBUSBITS[4:0]),
				.CLOCKS_PER_BAUD(BUSUART[DBGBUSBITS-1:0]))
		txv(i_clk,
				wbu_tx_stb,
				wbu_tx_data,
				o_wbu_uart_tx,
				wbu_tx_busy);

`ifdef	INCLUDE_ZIPCPU
`else
	assign	zip_dbg_ack   = 1'b0;
	assign	zip_dbg_stall = 1'b0;
	assign	zip_dbg_data  = 0;
`endif
`ifndef	BUSPIC_ACCESS
	wire	w_bus_int;
	assign	w_bus_int = 1'b0;
`endif
	wire	[31:0]	wbu_tmp_addr;
	wbuconsole genbus(i_clk, wbu_rx_stb, wbu_rx_data,
			wbu_cyc, wbu_stb, wbu_we, wbu_tmp_addr, wbu_data,
			wbu_ack, wbu_stall, wbu_err, wbu_idata,
			w_bus_int,
			wbu_tx_stb, wbu_tx_data, wbu_tx_busy,
			//
			w_console_tx_stb, w_console_tx_data, w_console_busy,
			w_console_rx_stb, w_console_rx_data,
			//
			wbubus_dbg[0]);
	assign	wbu_sel = 4'hf;
	assign	wbu_addr = wbu_tmp_addr[(29-1):0];
`else	// WBUBUS_MASTER

	// In the case that nothing drives the wbu bus ...
	assign	wbu_cyc = 1'b0;
	assign	wbu_stb = 1'b0;
	assign	wbu_we  = 1'b0;
	assign	wbu_sel = 0;
	assign	wbu_addr= 0;
	assign	wbu_data= 0;
	// verilator lint_off UNUSED
	wire	[35:0]	unused_bus_wbu;
	assign	unused_bus_wbu = { wbu_ack, wbu_stall, wbu_err, wbu_data };
	// verilator lint_on  UNUSED

`endif	// WBUBUS_MASTER


	reg	scope_hdmiin_trigger, scope_hdmiin_tmp, scope_hdmiin_pre_trigger,
		scope_hdmiin_count_triggered;
	wire	scope_hdmiin_clear_stb;
	reg	[31:0]	scope_hdmiin_counter, scope_hdmiin_trigger_foo;
	initial	scope_hdmiin_pre_trigger = 1'b1;
	always @(posedge i_hdmi_in_clk)
		if (scope_hdmiin_trigger_foo == 0)
		begin
			scope_hdmiin_trigger_foo <= 32'd2475000-1'b1;
			scope_hdmiin_pre_trigger <= 1'b1;
		end else begin
			scope_hdmiin_trigger_foo <= scope_hdmiin_trigger_foo-1'b1;
			scope_hdmiin_pre_trigger <= 1'b0;
		end

	transferstb scope_hdmiin_clearctri(i_clk, i_hdmi_in_clk,
		((wb_stb)&&(scope_hdmiin_sel)&&(wb_we)&&(!wb_addr[0])),
		scope_hdmiin_clear_stb);

	initial	scope_hdmiin_count_triggered = 1'b0;
	always @(posedge i_hdmi_in_clk)
		if (scope_hdmiin_clear_stb)
			scope_hdmiin_count_triggered <= 1'b0;
		else if (scope_hdmiin_pre_trigger)
			scope_hdmiin_count_triggered <= 1'b1;

	initial	scope_hdmiin_counter = 32'hffff_ffff;
	always @(posedge i_hdmi_in_clk)
		if (!scope_hdmiin_count_triggered)
			scope_hdmiin_counter <= hdmi_scope_frame_offset_data;
		else if (scope_hdmiin_counter != 0)
			scope_hdmiin_counter <= scope_hdmiin_counter - 1'b1;

	initial	scope_hdmiin_trigger = 1'b0;
	always @(posedge i_hdmi_in_clk)
		scope_hdmiin_trigger <= (scope_hdmiin_counter == 0);

	wbscope #(.LGMEM(5'd14), .SYNCHRONOUS(0)
		) copyhdmiin(i_hdmi_in_clk, 1'b1,
			scope_hdmiin_trigger, hin_dbg_scope,
		i_clk, wb_cyc, (wb_stb)&&(scope_hdmiin_sel), wb_we, wb_addr[0],
				{ wb_data[31:20], 20'h0 },
			scope_hdmiin_ack, scope_hdmiin_stall,
			scope_hdmiin_data,
		scop_hdmiin_int);
`ifdef	MICROPHONE_ACCESS
	wbmic #(.DEFAULT_RELOAD(2083))
 		microphone(i_clk, 1'b0,
 			wb_cyc, (wb_stb)&&(pmic_sel), wb_we,
				wb_addr[0], wb_data,
 			pmic_ack, pmic_stall, pmic_data,
			o_mic_csn, o_mic_sck, i_mic_din, pmic_int);
`else	// MICROPHONE_ACCESS
	assign	o_mic_csn    = 1'b1;
	assign	o_mic_sck    = 1'b1;

	// In the case that there is no pmic peripheral responding on the wb bus
	reg	r_pmic_ack;
	initial	r_pmic_ack = 1'b0;
	always @(posedge i_clk)	r_pmic_ack <= (wb_stb)&&(pmic_sel);
	assign	pmic_ack   = r_pmic_ack;
	assign	pmic_stall = 0;
	assign	pmic_data  = 0;

	assign	pmic_int = 1'b0;	// pmic.INT.MIC.WIRE
`endif	// MICROPHONE_ACCESS

`ifdef	GPIO_ACCESS
	//
	// GPIO
	//
	// This interface should allow us to control up to 16 GPIO inputs, and
	// another 16 GPIO outputs.  The interrupt trips when any of the inputs
	// changes.  (Sorry, which input isn't (yet) selectable.)
	//
	localparam	INITIAL_GPIO = 16'h0f;
	wbgpio	#(NGPI, NGPO, INITIAL_GPIO)
		gpioi(i_clk, 1'b1, (wb_stb)&&(gpio_sel), wb_we,
			wb_data, gpio_data, i_gpio, o_gpio,
			gpio_int);
`else	// GPIO_ACCESS

	// In the case that there is no gpio peripheral responding on the wb bus
	reg	r_gpio_ack;
	initial	r_gpio_ack = 1'b0;
	always @(posedge i_clk)	r_gpio_ack <= (wb_stb)&&(gpio_sel);
	assign	gpio_ack   = r_gpio_ack;
	assign	gpio_stall = 0;
	assign	gpio_data  = 0;

	assign	gpio_int = 1'b0;	// gpio.INT.GPIO.WIRE
`endif	// GPIO_ACCESS

	always @(posedge i_clk)
		if (wb_err)
			r_buserr_addr <= wb_addr;
	assign	buserr_data = { {(32-2-28){1'b0}},
			r_buserr_addr, 2'b00 };
`ifdef	SDRAM_ACCESS
	assign	o_sdram_cyc  = sdr_cyc;
	assign	o_sdram_stb  =(sdr_stb)&&(sdram_sel);
	assign	o_sdram_we   = sdr_we;
	assign	o_sdram_addr = sdr_addr;
	assign	o_sdram_data = sdr_data;
	assign	o_sdram_sel  = sdr_sel;
	assign	sdram_ack   = i_sdram_ack;
	assign	sdram_stall = i_sdram_stall;
	assign	sdram_data = i_sdram_data;
	 assign	sdram_err   = 1'b0; // i_sdram_err;

`else	// SDRAM_ACCESS

	// In the case that there is no sdram peripheral responding on the sdr bus
	reg	r_sdram_ack;
	initial	r_sdram_ack = 1'b0;
	always @(posedge i_clk)	r_sdram_ack <= (sdr_stb)&&(sdram_sel);
	assign	sdram_ack   = r_sdram_ack;
	assign	sdram_stall = 0;
	assign	sdram_data  = 0;

`endif	// SDRAM_ACCESS

`ifdef	GPSUART_ACCESS
	wbuart #(.INITIAL_SETUP(31'h000028b0))
 		gpsu_uart(i_clk, 1'b0,
 			wb_cyc, (wb_stb)&&(gpsu_sel), wb_we,
				wb_addr[1:0], wb_data,
 			gpsu_ack, gpsu_stall, gpsu_data,
 			i_gpsu_rx, o_gpsu_tx, w_gpsu_cts_n, w_gpsu_rts_n,
			gpsurx_int, gpsutx_int,
			gpsurxf_int, gpsutxf_int);
`else	// GPSUART_ACCESS
	assign	o_gpsu_tx    = 1'b1;
	assign	w_gpsu_rts_n = 1'b0;

	// In the case that there is no gpsu peripheral responding on the wb bus
	reg	r_gpsu_ack;
	initial	r_gpsu_ack = 1'b0;
	always @(posedge i_clk)	r_gpsu_ack <= (wb_stb)&&(gpsu_sel);
	assign	gpsu_ack   = r_gpsu_ack;
	assign	gpsu_stall = 0;
	assign	gpsu_data  = 0;

	assign	gpsutx_int = 1'b0;	// gpsu.INT.GPSTX.WIRE
	assign	gpsutxf_int = 1'b0;	// gpsu.INT.GPSTXF.WIRE
	assign	gpsurx_int = 1'b0;	// gpsu.INT.GPSRX.WIRE
	assign	gpsurxf_int = 1'b0;	// gpsu.INT.GPSRXF.WIRE
`endif	// GPSUART_ACCESS

`ifdef	BUSPIC_ACCESS
	//
	// The BUS Interrupt controller
	//
	icontrol #(15)	buspici(i_clk, 1'b0, (wb_stb)&&(buspic_sel),
			wb_data, buspic_data, bus_int_vector, w_bus_int);
`else	// BUSPIC_ACCESS

	// In the case that there is no buspic peripheral responding on the wb bus
	reg	r_buspic_ack;
	initial	r_buspic_ack = 1'b0;
	always @(posedge i_clk)	r_buspic_ack <= (wb_stb)&&(buspic_sel);
	assign	buspic_ack   = r_buspic_ack;
	assign	buspic_stall = 0;
	assign	buspic_data  = 0;

	assign	w_bus_int = 1'b0;	// buspic.INT.BUS.WIRE
`endif	// BUSPIC_ACCESS

	//
	//
	// Arbitrate between two busses
	//
	//
	// Clock speed = 100000000
	wbpriarbiter #(128,25)
		sdr_arb(i_clk,
			vid_cyc, (vid_stb)&&(vid_bus_sel), vid_we, vid_addr,
				vid_data, vid_sel,
			vid_bus_ack, vid_bus_stall, vid_bus_err,
		// The UART interface master
		(xpand_bus_cyc)&&(sdram_arbiter_sel),
			(xpand_bus_stb)&&(sdram_arbiter_sel),
			xpand_bus_we,
			xpand_bus_addr[(25-1):0],
			xpand_bus_data, xpand_bus_sel,
			sdram_arbiter_ack, sdram_arbiter_stall, sdram_arbiter_err,
		// Common bus returns
		sdram_arbiteri_cyc, sdram_arbiteri_stb, sdram_arbiteri_we, sdram_arbiteri_addr, sdram_arbiteri_odata, sdram_arbiteri_sel,
			sdram_arbiteri_ack, sdram_arbiteri_stall, sdram_arbiteri_err);

	busdelay #(25,128) sdram_arbiteri_delay(
		i_clk, i_reset,
		sdram_arbiteri_cyc, sdram_arbiteri_stb, sdram_arbiteri_we, sdram_arbiteri_addr, sdram_arbiteri_odata, sdram_arbiteri_sel,
			sdram_arbiteri_ack, sdram_arbiteri_stall, sdram_arbiteri_idata, sdram_arbiteri_err,
		sdr_cyc, sdr_stb, sdr_we, sdr_addr, sdr_data, sdr_sel,
			sdr_ack, sdr_stall, sdr_idata, sdr_err);
	assign	sdram_arbiter_data  = sdram_arbiteri_idata;
	assign	vid_bus_data = sdram_arbiteri_idata;
`ifdef	FLASHCTL_ACCESS
	// The Flash control interface result comes back together with the
	// flash interface itself.  Hence, we always return zero here.
	assign	flctl_ack   = 1'b0;
	assign	flctl_stall = 1'b0;
	assign	flctl_data  = 0;
`else	// FLASHCTL_ACCESS

	// In the case that there is no flctl peripheral responding on the wb bus
	reg	r_flctl_ack;
	initial	r_flctl_ack = 1'b0;
	always @(posedge i_clk)	r_flctl_ack <= (wb_stb)&&(flctl_sel);
	assign	flctl_ack   = r_flctl_ack;
	assign	flctl_stall = 0;
	assign	flctl_data  = 0;

`endif	// FLASHCTL_ACCESS

`ifdef	CFG_ACCESS
	wire[31:0]	cfg_debug;
`ifdef	VERILATOR
	reg	r_cfg_ack;
	always @(posedge i_clk)
		r_cfg_ack <= (wb_stb)&&(cfg_sel);
	assign	cfg_ack   = r_cfg_ack;
	assign	cfg_stall = 1'b0;
	assign	cfg_data  = 32'h00;
`else
	wbicapetwo #(ICAPE_LGDIV)
		cfgport(i_clk, wb_cyc, (wb_stb)&&(cfg_sel), wb_we,
			wb_addr[4:0], wb_data,
			cfg_ack, cfg_stall, cfg_data);
`endif
`else	// CFG_ACCESS

	// In the case that there is no cfg peripheral responding on the wb bus
	reg	r_cfg_ack;
	initial	r_cfg_ack = 1'b0;
	always @(posedge i_clk)	r_cfg_ack <= (wb_stb)&&(cfg_sel);
	assign	cfg_ack   = r_cfg_ack;
	assign	cfg_stall = 0;
	assign	cfg_data  = 0;

`endif	// CFG_ACCESS

`ifdef	SDSPI_ACCESS
	// SPI mapping
	wire	w_sd_cs_n, w_sd_mosi, w_sd_miso;

	sdspi	sdcardi(i_clk,
		wb_cyc,
			(wb_stb)&&(sdcard_sel),
			wb_we,
			wb_addr[1:0],
			wb_data,
			sdcard_ack, sdcard_stall, sdcard_data,
		w_sd_cs_n, o_sd_sck, w_sd_mosi, w_sd_miso,
		sdcard_int, 1'b1, sdspi_debug);

	assign	w_sd_miso = i_sd_data[0];
	assign	o_sd_data = { w_sd_cs_n, 3'b111 };
	assign	o_sd_cmd  = w_sd_mosi;
`else	// SDSPI_ACCESS
	assign	o_sd_sck   = 1'b1;
	assign	o_sd_cmd   = 1'b1;
	assign	o_sd_data  = 4'hf;

	// In the case that there is no sdcard peripheral responding on the wb bus
	reg	r_sdcard_ack;
	initial	r_sdcard_ack = 1'b0;
	always @(posedge i_clk)	r_sdcard_ack <= (wb_stb)&&(sdcard_sel);
	assign	sdcard_ack   = r_sdcard_ack;
	assign	sdcard_stall = 0;
	assign	sdcard_data  = 0;

	assign	sdcard_int = 1'b0;	// sdcard.INT.SDCARD.WIRE
`endif	// SDSPI_ACCESS

	busexpander #(.AWIN(27), .DWIN(32),
			.DWOUT(128))
		xpandi32x128(
			i_clk,
			(wb_cyc),
			(wb_stb)&&(xpand_sel),
			wb_we,
			wb_addr[(27-1):0],
			wb_data, wb_sel,
			xpand_ack, xpand_stall,
			xpand_data, xpand_err,
			//
			xpand_bus_cyc,
			xpand_bus_stb,
			xpand_bus_we,
			xpand_bus_addr,
			xpand_bus_data,
			xpand_bus_sel,
			xpand_bus_ack,
			xpand_bus_stall,
			xpand_bus_idata,
			xpand_bus_err);
`ifdef	SPIO_ACCESS
	assign	w_btn = { i_btnc, i_btnd, i_btnl, i_btnr, i_btnu };
	spio #(.NBTN(5), .NLEDS(8), .NSW(8)) spioi(i_clk,
		wb_cyc, (wb_stb)&&(spio_sel), wb_we, wb_data, wb_sel,
			spio_ack, spio_stall, spio_data,
		i_sw, w_btn, o_led, spio_int);
`else	// SPIO_ACCESS
	assign	w_btn    = h0;
	assign	o_led = 0;

	// In the case that there is no spio peripheral responding on the wb bus
	reg	r_spio_ack;
	initial	r_spio_ack = 1'b0;
	always @(posedge i_clk)	r_spio_ack <= (wb_stb)&&(spio_sel);
	assign	spio_ack   = r_spio_ack;
	assign	spio_stall = 0;
	assign	spio_data  = 0;

	assign	spio_int = 1'b0;	// spio.INT.SPIO.WIRE
`endif	// SPIO_ACCESS

`ifdef	RTC_ACCESS
`ifdef	GPSTRK_ACCESS
	rtcgps	#(RTC_CLKSTEP) thertc(i_clk, i_reset,
		wb_cyc, (wb_stb)&&(rtc_sel), wb_we, wb_addr[1:0], wb_data, wb_sel,
		rtc_ack, rtc_stall, rtc_data,
		rtc_int, rtc_ppd,
		gps_tracking, ck_pps, gps_step[47:16], rtc_pps);
`else
	rtclight #(32'h2af31d) thertc(i_clk, i_reset,
		wb_cyc, (wb_stb)&&(rtc_sel), wb_we, { 1'b0, wb_addr[1:0] },
			wb_data, wb_sel,
		rtc_stall, rtc_ack, rtc_data,
		rtc_int, rtc_ppd);
`endif
`else	// RTC_ACCESS
`ifdef	GPSTRK_ACCESS
	assign	rtc_pps = 1'b0;
`endif
	assign	rtc_ppd = 1'b0;

	// In the case that there is no rtc peripheral responding on the wb bus
	reg	r_rtc_ack;
	initial	r_rtc_ack = 1'b0;
	always @(posedge i_clk)	r_rtc_ack <= (wb_stb)&&(rtc_sel);
	assign	rtc_ack   = r_rtc_ack;
	assign	rtc_stall = 0;
	assign	rtc_data  = 0;

	assign	rtc_int = 1'b0;	// rtc.INT.RTC.WIRE
`endif	// RTC_ACCESS

`ifdef	BKRAM_ACCESS
	memdev #(.LGMEMSZ(20), .EXTRACLOCK(1))
		bkrami(i_clk, i_reset,
			(wb_cyc), (wb_stb)&&(bkram_sel), wb_we,
				wb_addr[(20-3):0], wb_data, wb_sel,
				bkram_ack, bkram_stall, bkram_data);
`else	// BKRAM_ACCESS

	// In the case that there is no bkram peripheral responding on the wb bus
	reg	r_bkram_ack;
	initial	r_bkram_ack = 1'b0;
	always @(posedge i_clk)	r_bkram_ack <= (wb_stb)&&(bkram_sel);
	assign	bkram_ack   = r_bkram_ack;
	assign	bkram_stall = 0;
	assign	bkram_data  = 0;

`endif	// BKRAM_ACCESS

`ifdef	NETCLOCKCTR_ACCESS
	clkcounter clknetclockctrctr(i_clk, ck_pps, i_net_rx_clk, netclockctr_data);
	always @(posedge i_clk)
		r_netclockctr_ack <= (wb_stb)&&(netclockctr_sel);
	assign	netclockctr_ack   = r_netclockctr_ack;
	assign	netclockctr_stall = 1'b0;
`else	// NETCLOCKCTR_ACCESS

	// In the case that there is no netclockctr peripheral responding on the wb bus
	reg	r_netclockctr_ack;
	initial	r_netclockctr_ack = 1'b0;
	always @(posedge i_clk)	r_netclockctr_ack <= (wb_stb)&&(netclockctr_sel);
	assign	netclockctr_ack   = r_netclockctr_ack;
	assign	netclockctr_stall = 0;
	assign	netclockctr_data  = 0;

`endif	// NETCLOCKCTR_ACCESS

`ifdef	PWRCOUNT_ACCESS
	initial	r_pwrcount_data = 32'h0;
	always @(posedge i_clk)
	if (r_pwrcount_data[31])
		r_pwrcount_data[30:0] <= r_pwrcount_data[30:0] + 1'b1;
	else
		r_pwrcount_data[31:0] <= r_pwrcount_data[31:0] + 1'b1;
	assign	pwrcount_data = r_pwrcount_data;
`else	// PWRCOUNT_ACCESS

	// In the case that there is no pwrcount peripheral responding on the wb bus
	reg	r_pwrcount_ack;
	initial	r_pwrcount_ack = 1'b0;
	always @(posedge i_clk)	r_pwrcount_ack <= (wb_stb)&&(pwrcount_sel);
	assign	pwrcount_ack   = r_pwrcount_ack;
	assign	pwrcount_stall = 0;
	assign	pwrcount_data  = 0;

`endif	// PWRCOUNT_ACCESS

`ifdef	RTCDATE_ACCESS
	//
	// The Calendar DATE
	//
	rtcdate	rtcdatei(i_clk, rtc_ppd,
		(wb_stb)&&(rtcdate_sel), wb_we, wb_data, wb_sel,
			rtcdate_ack, rtcdate_stall, rtcdate_data);
`else	// RTCDATE_ACCESS

	// In the case that there is no rtcdate peripheral responding on the wb bus
	reg	r_rtcdate_ack;
	initial	r_rtcdate_ack = 1'b0;
	always @(posedge i_clk)	r_rtcdate_ack <= (wb_stb)&&(rtcdate_sel);
	assign	rtcdate_ack   = r_rtcdate_ack;
	assign	rtcdate_stall = 0;
	assign	rtcdate_data  = 0;

`endif	// RTCDATE_ACCESS

`ifdef	BUSCONSOLE_ACCESS
	wbconsole #(.LGFLEN(6)) console(i_clk, 1'b0,
 			wb_cyc, (wb_stb)&&(uart_sel), wb_we,
				wb_addr[1:0], wb_data,
 			uart_ack, uart_stall, uart_data,
			w_console_tx_stb, w_console_tx_data, w_console_busy,
			w_console_rx_stb, w_console_rx_data,
			uartrx_int, uarttx_int, uartrxf_int, uarttxf_int);
`else	// BUSCONSOLE_ACCESS

	// In the case that there is no uart peripheral responding on the wb bus
	reg	r_uart_ack;
	initial	r_uart_ack = 1'b0;
	always @(posedge i_clk)	r_uart_ack <= (wb_stb)&&(uart_sel);
	assign	uart_ack   = r_uart_ack;
	assign	uart_stall = 0;
	assign	uart_data  = 0;

	assign	uarttxf_int = 1'b0;	// uart.INT.UARTTXF.WIRE
	assign	uartrxf_int = 1'b0;	// uart.INT.UARTRXF.WIRE
	assign	uarttx_int = 1'b0;	// uart.INT.UARTTX.WIRE
	assign	uartrx_int = 1'b0;	// uart.INT.UARTRX.WIRE
`endif	// BUSCONSOLE_ACCESS

`ifdef	NETCTRL_ACCESS
	wire[31:0]	mdio_debug;
	enetctrl #(2)
		mdio(i_clk, i_reset, wb_cyc, (wb_stb)&&(mdio_sel), wb_we,
				wb_addr[4:0], wb_data[15:0],
			mdio_ack, mdio_stall, mdio_data,
			o_mdclk, o_mdio, i_mdio, o_mdwe, mdio_debug);
`else	// NETCTRL_ACCESS
	assign	o_mdclk = 1'b1;
	assign	o_mdio  = 1'b1;
	assign	o_mdwe  = 1'b0;;

	// In the case that there is no mdio peripheral responding on the wb bus
	reg	r_mdio_ack;
	initial	r_mdio_ack = 1'b0;
	always @(posedge i_clk)	r_mdio_ack <= (wb_stb)&&(mdio_sel);
	assign	mdio_ack   = r_mdio_ack;
	assign	mdio_stall = 0;
	assign	mdio_data  = 0;

`endif	// NETCTRL_ACCESS



endmodule // main.v
